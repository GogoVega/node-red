/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

export declare namespace nodes {
    /**
     * The Unique Node ID:
     * A set of 16 number or lower alphabetic characters
     */
    type UID = string;

    /** Reserved name for properties that MUST NOT BE USED. */
    type ReservedProperties =
        | "changed"
        | "colorChanged"
        | "dirty"
        | "icon"
        | "id"
        | "info"
        | "inputLabels"
        | "label"
        | "moved"
        | "outputLabels"
        | "ports"
        | "reordered"
        | "selected"
        | "type"
        | "users"
        | "valid"
        | "validationErrors"
        | "wires"
        | "a"
        | "b"
        | "c"
        | "d"
        | "e"
        | "f"
        | "g"
        | "h"
        | "i"
        | "j"
        | "k"
        | "l"
        | "m"
        | "n"
        | "o"
        | "p"
        | "q"
        | "r"
        | "s"
        | "t"
        | "u"
        | "v"
        | "w"
        | "x"
        | "y"
        | "z";

    /** Name for properties that are NOT importable/exportable. */
    type NotExportedProperties =
        | "_"
        | "_config"
        | "_def"
        | "changed"
        | "colorChanged"
        | "dirty"
        | "moved"
        | "reordered"
        | "selected"
        | "users"
        | "valid"
        | "validationErrors"
        | "a"
        | "b"
        | "c"
        | "e"
        | "f"
        | "h"
        | "i"
        | "j"
        | "k"
        | "m"
        | "n"
        | "o"
        | "p"
        | "q"
        | "r"
        | "s"
        | "t"
        | "u"
        | "v"
        | "w";

    type NodeCredentials = Record<string, string>;

    /**
     * Node properties
     * @see {@link https://nodered.org/docs/creating-nodes/properties}
     */
    interface NodeProperties {
        name?: string;
        inputs?: 0 | 1;
        outputs?: number;
    }

    interface CredentialDefinition {
        /**
         * The credential label. Shown in the error badge/input popover.
         */
        label?: string;
        /**
         * The default value the credential takes. **Do not use it for legacy property**.
         */
        value?: any;
        /**
         * Whether the value must be non-empty
         */
        required?: boolean;
        validate?: ((this: BaseNode, value: string, opt?: object) => boolean | string) | undefined
        type: "text" | "password";
    }

    /**
     * Property definition
     * @see {@link https://nodered.org/docs/creating-nodes/properties#property-definitions}
     */
    interface PropertyDefinition {
        /**
         * The property label. Shown in the error badge/input popover.
         */
        label?: string;
        /**
         * The default value the property takes. **Do not use it for legacy property**.
         */
        value?: any;
        /**
         * Whether the value must be non-empty
         */
        required?: boolean;
        validate?: ((this: BaseNode, value: string, opt?: object) => boolean | string) | undefined;
        /**
         * Selector to a config node type
         */
        type?: string;
        /**
         * Defines the 'real' type for lists of nodes
         * @internal
         */
        _type?: { type: string; array: true };
    }

    /** This type converts a node into its exportable form */
    type NodeObject<T extends BaseNode = BaseNode> = Omit<T, NotExportedProperties> & Omit<T["credentials"], "_">;

    //type NodeInstance<TProps extends NodeProperties = {}, TCreds extends NodeCredentials = {}> = Omit<TProps, ReservedProperties> & BaseNode;

    interface BaseNode {
        _: i18n.I18nT;
        /**
         * Loaded node configuration
         * @internal
         */
        _config: object;
        /**
         * Node definition
         * @internal
         */
        _def: object;
        /** The Unique Node ID */
        id: UID;
        type: string;
        /** Whether the node configuration has changed */
        changed: boolean;
        /** The node credentials */
        credentials?: {
            /**
             * Loaded credentials
             * @internal
             */
            _?: Record<string, string>;
        };
        /**
         * The flow, subflow or group ID. If the node is a Config Node,
         * the value can be undefined to use the global config
         */
        z?: UID;
    }

    interface Node extends BaseNode {
        _def: object;
        /** Whether the node color has changed and needs to be redrawn */
        colorChanged?: true;
        /** Whether the node is disabled */
        d?: true;
        /** Whether the node needs to be redrawn */
        dirty: boolean;
        /** Whether the node is included in a group */
        g?: nodes.UID;
        /** The node height in the 'flow' space */
        h?: number;
        /** An icon from file or Font Awesome */
        icon?: string;
        /** Description of the node */
        info?: string;
        /** The input count */
        inputs: 0 | 1;
        /** A list of input labels */
        inputLabels?: string[];
        /** Show/Hide the node label */
        l?: false;
        /** The node label */
        label?: string | ((this: Node) => string);
        /** Whether the node has moved */
        moved?: true;
        /** The output count */
        outputs: number;
        /** Whether the node has been reordered */
        reordered?: true;
        /** A list of output labels */
        outputLabels?: string[];
        /** Whether the node is selected */
        selected?: true;
        /** Whether the node has a valid configuration */
        valid: boolean;
        /** A list of error messages shown in the badge */
        validationErrors: string[];
        /** The node weight in the 'flow' space */
        w?: number;
        /** A list of linked nodes */
        wires?: Array<[UID]>;
        /** The horizontal position on the canvas */
        x: number;
        /** The vertical position on the canvas */
        y: number;
        z: nodes.UID;
    }

    interface Group extends BaseNode {
        env?: object[];
    }

    interface Link extends BaseNode {
        source: BaseNode;
        sourcePort: number;
        target: BaseNode;
    }

    interface Subflow extends BaseNode {}
    interface Workspace extends BaseNode {}
    interface Junction extends BaseNode {}
}

export declare namespace events {
    interface Events {
        /**
         * The dirty state of the editor has changed.
         */
        "workspace:dirty": { dirty: boolean; };
    }
}

export declare namespace history {
    /**
     * Represent an History event
     */
    type HistoryEvent =
        | AddEvent
        | DeleteEvent
        | EditEvent
        | MoveEvent
        | MultiEvent
        | ReorderEvent
        | ReplaceEvent
        | CreateSubflowEvent
        | DeleteSubflowEvent
        | AddToGroupEvent
        | CreateGroupEvent
        | UngroupEvent
        | RemoveFromGroupEvent;

    /**
     * Represents the type of a History event.
     */
    type HistoryType =
        | "add"
        | "delete"
        | "edit"
        | "move"
        | "multi"
        | "reorder"
        | "replace"
        | "createSubflow"
        | "deleteSubflow"
        | "addToGroup"
        | "createGroup"
        | "ungroup"
        | "removeFromGroup";

    interface BaseEvent {
        /**
         * The history event type
         */
        t: HistoryType;
        /**
         * Whether the workspace is dirty
         */
        dirty: boolean;
        /**
         * A called after the undo/redo event
         */
        callback?: (event: HistoryEvent) => void;
    }

    /**
     * Represents an event for adding elements to the history.
     */
    interface AddEvent extends BaseEvent {
        t: "add";
        /**
         * An array with added groups
         */
        groups?: nodes.Group[];
        /**
         * An array with added junctions
         */
        junctions?: nodes.Junction[];
        /**
         * An array with added links
         */
        links?: nodes.Link[];
        /**
         * An array with added node ids
         */
        nodes?: nodes.UID[];
        /**
         * An array with removed links
         */
        removedLinks?: nodes.Link[];
        subflow?: {
            id: string;
            changed?: boolean;
            instances: nodes.BaseNode[];
        };
        /**
         * An array with added subflows (tabs)
         */
        subflows?: nodes.Subflow[];
        /**
         * An array with added workspaces
         */
        workspaces?: nodes.Workspace[];
    }

    /**
     * Represents an event for adding nodes to a group.
     */
    interface AddToGroupEvent extends BaseEvent {
        t: "addToGroup";
        /**
         * The group in which remove nodes
         */
        group: nodes.Group;
        /**
         * An array of nodes or one node to remove from the group
         */
        nodes?: nodes.BaseNode[] | nodes.BaseNode;
        /**
         * Either to re-add to parent group
         */
        reparent?: boolean;
    }

    /**
     * Represents an event for creating a group.
     */
    interface CreateGroupEvent extends BaseEvent {
        t: "createGroup";
        /**
         * An array with groups to remove
         */
        groups?: nodes.Group[];
    }

    /**
     * Represents an event for creating a subflow.
     */
    interface CreateSubflowEvent extends BaseEvent {
        t: "createSubflow";
        /**
         * The ID of the active workspace
         */
        activeWorkspace: nodes.UID;
        /**
         * An array with added links (during conversion to Subflow - links inside the subflow)
         */
        links?: nodes.Link[];
        /**
         * An array with subflow node IDs
         */
        nodes?: nodes.UID[];
        /**
         * An array with removed links (during conversion to Subflow - links from active workspace)
         */
        removedLinks?: nodes.Link[];
        /**
         * The subflow created to delete
         */
        subflow: {
            subflow: nodes.Subflow;
            offsetX?: number;
            offsetY?: number;
        };
    }
    
    /**
     * Represents an event for deleting elements from the history.
     */
    interface DeleteEvent extends BaseEvent {
        t: "delete";
        /**
         * An object with changes.
         * The key is the node ID and the value is an object with the changes
         */
        changes?: Record<nodes.UID, object>;
        /**
         * An array with created links
         */
        createdLinks?: nodes.Link[];
        /**
         * An array with removed groups
         */
        groups?: nodes.Group[];
        /**
         * An array with removed junctions
         */
        junctions?: nodes.Junction[];
        /**
         * An array with removed links
         */
        links?: nodes.Link[];
        /**
         * An array with removed nodes
         */
        nodes?: nodes.BaseNode[];
        subflow?: {
            id?: nodes.UID;
            instances?: nodes.BaseNode[];
            status?: string;
        };
        /**
         * An array with removed subflow input
         */
        subflowInputs?: nodes.SubflowNode[];
        /**
         * An array with removed subflow outputs
         */
        subflowOutputs?: nodes.SubflowNode[];
        /**
         * An array with removed subflows (tabs)
         */
        subflows?: nodes.Subflow[];
        /**
         * An array with removed workspace
         */
        workspaces?: nodes.Workspace[];
    }

    /**
     * Represents an event for deleting a subflow.
     */
    interface DeleteSubflowEvent extends BaseEvent {
        t: "deleteSubflow";
        /**
         * The id of the active workspace
         */
        activeWorkspace: nodes.UID;
        /**
         * An array with added links (during undo conversion to Subflow - links from active workspace)
         */
        createdLinks?: nodes.Link[];
        /**
         * An array with removed links (during undo conversion to Subflow - links inside the subflow)
         */
        links?: nodes.Link[];
        /**
         * An array with nodes to move to the subflow to create
         */
        movedNodes?: nodes.BaseNode[];
        /**
         * The deleted subflow to create
         */
        subflow: {
            subflow: nodes.Subflow;
            offsetX?: number;
            offsetY?: number;
        };
        /**
         * An array with subflow nodes (redo conversion to subflow)
         */
        subflows?: nodes.Subflow[];
    }

    /**
     * Represents an event for editing a node.
     */
    interface EditEvent extends BaseEvent {
        t: "edit";
        /**
         * The changed node state before modifications
         */
        changed: boolean;
        /**
         * An object with previous node properties value
         */
        changes: object;
        /**
         * An array with links to create (redo)
         */
        createdLinks?: nodes.Link[];
        /**
         * An array with removed links
         */
        links?: nodes.Link[];
        /**
         * The current node/subflow
         */
        node: nodes.BaseNode | nodes.Subflow;
        outputMap?: object;
        /**
         * Subflow properties
         */
        subflow?: {
            instances?: nodes.BaseNode[];
            inputCount?: number;
            outputCount?: number;
            status?: string;
        };
    }
    
    /**
     * Represents an event for moving nodes.
     */
    interface MoveEvent extends BaseEvent {
        t: "move";
        /**
         * The group in which the nodes were added
         */
        addToGroup?: nodes.Group;
        links?: nodes.Link[];
        /**
         * An array with nodes moved
         */
        nodes: { n: nodes.BaseNode; ox: number; oy: number; dx: number; dy: number }[];
        removedLinks?: nodes.Link[];
        /**
         * The group in which the nodes were removed
         */
        removeFromGroup?: nodes.Group;
    }
    
    /**
     * Represents an event for multiple sub-events.
     */
    interface MultiEvent extends BaseEvent {
        t: "multi";
        /**
         * An array with sub-events
         */
        events: HistoryEvent[];
    }

    /**
     * Represents an event for removing nodes from a group.
     */
    interface RemoveFromGroupEvent extends BaseEvent {
        t: "removeFromGroup";
        /**
         * The group in which add nodes
         */
        group: nodes.Group;
        /**
         * An array of nodes or one node to add to the group
         */
        nodes?: nodes.BaseNode[] | nodes.BaseNode;
        /**
         * Either to re-add to parent group
         */
        reparent?: boolean;
    }
    
    /**
     * Represents an event for reordering nodes or workspaces.
     */
    interface ReorderEvent extends BaseEvent {
        t: "reorder";
        nodes?: { from: string; to: string; z: string };
        workspaces?: {
            from: nodes.UID[];
            to: nodes.UID[];
        };
    }

    /**
     * Represents a replacement event (complete or incomplete).
     */
    type ReplaceEvent = CompleteReplaceEvent | IncompleteReplaceEvent;

    /**
    * Represents a complete replacement event.
    */
    interface CompleteReplaceEvent extends BaseEvent {
        t: "replace";
        /**
         * An object with a node id as key and the node changed property as value
         */
        changed: Record<string, boolean>;
        /**
         * Either the {@link ReplaceEvent.config} property contains the complete flows
         */
        complete: true;
        /**
         * An array with the complete flows
         */
        config: nodes.BaseNode[];
        /**
         * An object with a node ID as key and the node moved property as value
         */
        moved: Record<nodes.UID, boolean>;
        /**
         * A revision version
         */
        rev: string;
    }
    
    /**
    * Represents an incomplete replacement event.
    */
    interface IncompleteReplaceEvent extends BaseEvent {
        t: "replace";
        /**
         * Either the {@link ReplaceEvent.config} property contains the complete flows
         */
        complete?: false;
        /**
         * An array with config nodes and/or subflow definitions to replace.
         */
        config: nodes.BaseNode[];
    }

    /**
     * Represents an event for ungrouping nodes.
     */
    interface UngroupEvent extends BaseEvent {
        t: "ungroup";
        /**
         * An array with groups to create
         */
        groups?: nodes.Group[];
    }
}

export declare namespace i18n {
    type I18nT = (id: string, tplStrs?: Record<string, string | number>) => string;
}

export interface Events {
    emit<K extends keyof events.Events>(event: K, data: events.Events[K]): void;
}

export interface History {
    /**
     * @internal
     */
    markAllDirty(): void;
    /**
     * Returns a list with undo events.
     */
    list(): history.HistoryEvent[];
    /**
     * Returns a list with redo events.
     */
    listRedo(): history.HistoryEvent[];
    /**
     * Returns the size of the list with redo events.
     */
    depth(): number;
    /**
     * Pushes an event to the History. This event can be undo by
     * calling {@link History.pop pop}().
     * @param event The event to push
     */
    push(event: history.HistoryEvent): void;
    /**
     * Called to undo an event.
     * Takes the last event of the undo list, do undo event and adds
     * the redo event generated to the redo list.
     */
    pop(): void;
    /**
     * Returns the last event of undo list.
     */
    peek(): history.HistoryEvent;
    /**
     * Replaces the last event of undo list by the event given
     * in parameter.
     * @param event The event to replace
     */
    replace(event: history.HistoryEvent): void;
    /**
     * Clears the undo list and redo list.
     */
    clear(): void;
    /**
     * Called to redo an event.
     * Takes the last event of the redo list, do redo event and adds
     * the undo event generated to the undo list.
     */
    redo(): void;
}

export interface Nodes {
    //readonly registry: nodes.Registry;

    /**
     * Cleans all nodes and workspaces. Returns to a clean state before the first import.
     */
    clear(): void;
    /**
     * Get the dirty state of the editor. `Dirty` means there are undeployed changes.
     */
    dirty(): boolean;
    /**
     * Defines the dirty state of the editor. Triggers the {@link events.Events workspace:dirty} event.
     * @param dirty 
     */
    dirty(dirty: boolean): void;
    /**
     * Generates a unique node ID.
     */
    id(): nodes.UID;
    version(): string;
    version(version: string): void;

    node(id: nodes.UID): nodes.BaseNode | null;
    add(node: nodes.NodeObject): nodes.BaseNode;
    
    remove(id: nodes.UID): { links: nodes.Link[]; nodes: nodes.BaseNode[] };

    group(id: nodes.UID): nodes.Group | null;

    junction(id: nodes.UID): nodes.Junction | null;

    getNodeLinks(id: nodes.UID, portType: 0 | 1): nodes.Link[];
    /** @deprecated */
    getNodeLinks(link: nodes.Link, portType: 0 | 1): nodes.Link[];

    subflow(id: nodes.UID): nodes.Subflow | null;
    /**
     * Add a Subflow to the Workspace
     * @param subflow The Subflow to add
     * @param updateName Whether to update the name.
     */
    addSubflow(subflow: nodes.NodeObject<nodes.Subflow>, updateName?: boolean): void;
    removeSubflow(subflow: nodes.Subflow): void;
    subflowContains(subflowId: nodes.UID, nodeId: nodes.UID): boolean;

    workspace(id: nodes.UID): nodes.Workspace | null;
    addWorkspace(workspace: nodes.NodeObject<nodes.Workspace>, targetIndex?: number): void;
    removeWorkspace(id: nodes.UID): {
        nodes: nodes.BaseNode[];
        links: nodes.Link[];
        groups: nodes.Group[];
        junctions: nodes.Junction[]
    };
    getWorkspaceOrder(): nodes.UID[];
    setWorkspaceOrder(order: nodes.UID[]): void;

    eachConfig(callback: (node: nodes.ConfigNode) => void | false): void;
    eachGroup(callback: (node: nodes.Group) => void | false): void;
    eachJunction(callback: (node: nodes.Junction) => void | false): void;
    eachLink(callback: (node: nodes.Link) => void | false): void;
    eachNode(callback: (node: nodes.BaseNode) => void | false): void;
    eachSubflow(callback: (node: nodes.Subflow) => void | false): void;
    eachWorkspace(callback: (node: nodes.Workspace) => void | false): void;

    import(nodes, options): {
        nodes: nodes.BaseNode[];
        links: {
            source: nodes.BaseNode;
            sourcePort: number;
            target: nodes.BaseNode;
        }[];
        groups: nodes.Group[];
        junctions: nodes.Junction[];
        workspaces: nodes.Workspace[];
        subflows: nodes.Subflow[];
        missingWorkspace: nodes.Workspace;
        removedNodes: nodes.BaseNode[] | undefined;
    } | undefined;

    originalFlow(): nodes.NodeObject[];
    /** @internal */
    originalFlow(flow: nodes.NodeObject[]): void;

    /**
     * Converts a node to an exportable JSON Object
     */
    convertNode(node: nodes.BaseNode, exportCreds: boolean): nodes.NodeObject;
    /**
     * Converts the current node selection to an exportable JSON Object
     */
    createExportableNodeSet(
        set: object[],
        exportedIds?: object,
        exportedSubflows?: object,
        exportedConfigNodes?: object,
    ): Array<nodes.NodeObject>;
    /**
     * Converts the complete flow to an exportable JSON Object
     */
    createCompleteNodeSet(options?: { credentials?: boolean, dimensions?: boolean }): Array<nodes.NodeObject>;
    updateConfigNodeUsers(node: nodes.Node, options?: { action?: "add" | "remove", emitEvent?: boolean }): void;
}

export interface RED {
    _: i18n.I18nT;
    events: Events;
    /**
     * The History API for undo / redo history buffer
     */
    history: History;
    /**
     * The Nodes API
     */
    nodes: Nodes;
}

declare global {
    /**
     * The Node-RED Editor API
     */
    var RED: RED;

    // TODO: JQuery + typedInput + editableList
}
