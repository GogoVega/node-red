/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

export declare namespace nodes {
    /**
     * The Unique Node ID:
     * A set of 16 number or lower alphabetic characters
     */
    type UID = string;

    /** Reserved name for properties that MUST NOT BE USED. */
    type ReservedProperties =
        | "changed"
        | "colorChanged"
        | "dirty"
        | "icon"
        | "id"
        | "info"
        | "inputLabels"
        | "label"
        | "moved"
        | "outputLabels"
        | "ports"
        | "reordered"
        | "selected"
        | "type"
        | "users"
        | "valid"
        | "validationErrors"
        | "wires"
        | "a"
        | "b"
        | "c"
        | "d"
        | "e"
        | "f"
        | "g"
        | "h"
        | "i"
        | "j"
        | "k"
        | "l"
        | "m"
        | "n"
        | "o"
        | "p"
        | "q"
        | "r"
        | "s"
        | "t"
        | "u"
        | "v"
        | "w"
        | "x"
        | "y"
        | "z";

    /** Name for properties that are NOT importable/exportable. */
    type NotExportedProperties =
        | "_"
        | "_config"
        | "_def"
        | "changed"
        | "colorChanged"
        | "dirty"
        | "moved"
        | "reordered"
        | "selected"
        | "users"
        | "valid"
        | "validationErrors"
        | "a"
        | "b"
        | "c"
        | "e"
        | "f"
        | "h"
        | "i"
        | "j"
        | "k"
        | "m"
        | "n"
        | "o"
        | "p"
        | "q"
        | "r"
        | "s"
        | "t"
        | "u"
        | "v"
        | "w";

    type NodeCredentials = Record<string, string>;

    /**
     * Node properties
     * @see {@link https://nodered.org/docs/creating-nodes/properties}
     */
    interface NodeProperties {
        name?: string;
        inputs?: 0 | 1;
        outputs?: number;
    }

    interface CredentialDefinition {
        /**
         * The credential label. Shown in the error badge/input popover.
         */
        label?: string;
        /**
         * The default value the credential takes. **Do not use it for legacy property**.
         */
        value?: any;
        /**
         * Whether the value must be non-empty
         */
        required?: boolean;
        validate?: PropertyValidator;
        type: "text" | "password";
    }

    /**
     * Property definition
     * @see {@link https://nodered.org/docs/creating-nodes/properties#property-definitions}
     */
    interface PropertyDefinition {
        /**
         * The property label. Shown in the error badge/input popover.
         */
        label?: string;
        /**
         * The default value the property takes. **Do not use it for legacy property**.
         */
        value?: any;
        /**
         * Whether the value must be non-empty
         */
        required?: boolean;
        validate?: PropertyValidator;
        /**
         * Selector to a config node type
         */
        type?: string;
        /**
         * Defines the 'real' type for lists of nodes
         * @internal
         */
        _type?: { type: string; array: true };
    }

    type PropertyValidator = (this: BaseNode, value: string, opt: { label?: string; }) => boolean | string;

    /** This type converts a node into its exportable form */
    type NodeObject<T extends BaseNode = BaseNode> = Omit<T, NotExportedProperties> & Omit<T["credentials"], "_">;

    //type NodeInstance<TProps extends NodeProperties = {}, TCreds extends NodeCredentials = {}> = Omit<TProps, ReservedProperties> & BaseNode;

    interface BaseNode {
        _: i18n.I18nT;
        /**
         * Loaded node configuration
         * @internal
         */
        _config: object;
        /**
         * Node definition
         * @internal
         */
        _def: object;
        /** The Unique Node ID */
        id: UID;
        type: string;
        /** Whether the node configuration has changed */
        changed: boolean;
        /** The node credentials */
        credentials?: {
            /**
             * Loaded credentials
             * @internal
             */
            _?: Record<string, string>;
        };
        /**
         * The flow, subflow or group ID. If the node is a Config Node,
         * the value can be undefined to use the global config
         */
        z?: UID;
    }

    interface Node extends BaseNode {
        _def: object;
        /** Whether the node color has changed and needs to be redrawn */
        colorChanged?: true;
        /** Whether the node is disabled */
        d?: true;
        /** Whether the node needs to be redrawn */
        dirty: boolean;
        /** Whether the node is included in a group */
        g?: nodes.UID;
        /** The node height in the 'flow' space */
        h?: number;
        /** An icon from file or Font Awesome */
        icon?: string;
        /** Description of the node */
        info?: string;
        /** The input count */
        inputs: 0 | 1;
        /** A list of input labels */
        inputLabels?: string[];
        /** Show/Hide the node label */
        l?: false;
        /** The node label */
        label?: string | ((this: Node) => string);
        /** Whether the node has moved */
        moved?: true;
        /** The output count */
        outputs: number;
        /** Whether the node has been reordered */
        reordered?: true;
        /** A list of output labels */
        outputLabels?: string[];
        /** Whether the node is selected */
        selected?: true;
        /** Whether the node has a valid configuration */
        valid: boolean;
        /** A list of error messages shown in the badge */
        validationErrors: string[];
        /** The node weight in the 'flow' space */
        w?: number;
        /** A list of linked nodes */
        wires?: Array<[UID]>;
        /** The horizontal position on the canvas */
        x: number;
        /** The vertical position on the canvas */
        y: number;
        z: nodes.UID;
    }

    interface Group extends BaseNode {
        env?: object[];
    }

    interface Link extends BaseNode {
        source: BaseNode;
        sourcePort: number;
        target: BaseNode;
    }

    interface Subflow extends BaseNode {}
    interface Workspace extends BaseNode {}
    interface Junction extends BaseNode {}
}

// TODO: complete editor interfaces
export declare namespace editor {
    type NodePrefix = "node-config-input" | "node-input";

    interface EditorOptions {
        element?: JQuery;
        id?: string;
        mode?: string;
        foldStyle?: string;
        options?: object;
        readOnly?: boolean;
        value?: string;
        globals?: object;
    }

    interface Tray {
        buttons?: TrayButton[];
        focusElement?: boolean;
        maximized?: boolean;
        title?: string;
        width?: number;

        close?: () => void;
        open?: (tray: JQuery<HTMLElement>, done?: () => void) => void;
        resize?: (options: TrayResizeOptions) => void;
        show?: () => void;
    }
    interface TrayButton {
        id?: string;
        class?: string;
        click?: (this: widgets.ToogleButton, event: JQuery.ClickEvent) => void;
        text?: string;
    }

    interface TrayOptions extends Tray {
        overlay?: boolean;
        width?: "inherit" | number;
    }

    interface TrayResizeOptions {
        width: number;
        height?: number;
    }
}

export declare namespace events {
    type DefaultListener = {
        [k: string]: (...args: any[]) => void;
    };

    type ListenerSignature<L> = {
        [E in keyof L]: (...args: any[]) => void;
    };

    /**
     * @link https://nodered.org/docs/api/ui/events/#available-events
     */
    interface Events extends DefaultListener {
        /** @internal */
        "actionList:close": () => void;
        /** @internal */
        "actionList:open": () => void;
        /**
         * A new flow has been deployed
         */
        deploy: () => void;
        /** @internal */
        "editor:change": () => void;
        /** @internal */
        "editor:close": () => void;
        /** @internal */
        "editor:open": () => void;
        /** @internal */
        "editor:save": (node: nodes.BaseNode) => void;
        /**
         * A new flow has been added
         */
        "flows:add": (workspace: nodes.Workspace) => void;
        /**
         * A flow’s properties have been changed
         */
        "flows:change": (workspace: nodes.Workspace) => void;
        /** @internal */
        "flows:loaded": () => void;
        /**
         * A flow has been removed
         */
        "flows:remove": (workspace: nodes.Workspace) => void;
        /**
         * The flows have been reordered
         */
        "flows:reorder": (workspaces: nodes.UID[]) => void;
        /**
         * A new group has been added
         */
        "groups:add": (group: nodes.Group) => void;
        /**
         * A group’s properties have been changed
         */
        "groups:change": (group: nodes.Group) => void;
        /**
         * A new group has been removed
         */
        "groups:remove": (group: nodes.Group) => void;
        /**
         * A new junction has been added
         */
        "junctions:add": (junction: nodes.Junction) => void;
        /**
         * A junction’s properties have been changed
         */
        "junctions:change": (junction: nodes.Junction) => void;
        /**
         * A new junction has been removed
         */
        "junctions:remove": (junction: nodes.Junction) => void;
        /**
         * A new link has been added
         */
        "links:add": (link: nodes.Workspace) => void;
        /**
         * A new link has been removed
         */
        "links:remove": (link: nodes.Workspace) => void;
        /**
         * A user has logged into the editor.
         * If `adminAuth` is not configured, this event is never emitted
         */
        login: (user: string) => void;
        /**
         * The current user has logged out.
         */
        logout: () => void;
        /**
         * A new node has been added
         */
        "nodes:add": (node: nodes.BaseNode) => void;
        /**
         * A node’s properties have been changed
         */
        "nodes:change": (node: nodes.BaseNode) => void;
        /**
         * A new node has been removed
         */
        "nodes:remove": (node: nodes.BaseNode) => void;
        /**
         * Nodes have been reordered on a flow
         */
        "nodes:reorder": (z: nodes.UID, nodes: nodes.BaseNode[]) => void;
        "project:change": (change: { name: string; }) => void;
        /** @internal */
        "projects:load": (project: object) => void;
        /**
         * A module has updated to a new version
         */
        "registry:module-updated": (module: { module: string; version: string; }) => void;
        /**
         * A new Node-Set has been added to the palette
         */
        "registry:node-set-added": (set: nodes.Node) => void;
        /**
         * A Node-Set has been disabled
         */
        "registry:node-set-disabled": (set: nodes.Node) => void;
        /**
         * A Node-Set has been enabled
         */
        "registry:node-set-enabled": (set: nodes.Node) => void;
        /**
         * A Node-Set has been removed
         */
        "registry:node-set-removed": (set: nodes.Node) => void;
        /**
         * A new Node has been added to the palette
         */
        "registry:node-type-added": (type: string) => void;
        /**
         * A Node has been removed from the palette
         */
        "registry:node-type-removed": (type: string) => void;
        /**
         * A Plugin has been added
         */
        "registry:plugin-added": (name: string) => void;
        /** @internal */
        "registry:plugin-module-added": (name: string) => void;
        /** @internal */
        "runtime-state": (state: Record<string, any>) => void;
        /** @internal */
        "search:close": () => void;
        /** @internal */
        "search:open": () => void;
        /** @internal */
        "sidebar:resize": () => void;
        /**
         * A new subflow has been added
         */
        "subflows:add": (subflow: nodes.Subflow) => void;
        /**
         * A subflow’s properties have been changed
         */
        "subflows:change": (subflow: nodes.Subflow) => void;
        /**
         * A new subflow has been removed
         */
        "subflows:remove": (subflow: nodes.Subflow) => void;
        /** @internal */
        "type-search:close": () => void;
        /** @internal */
        "type-search:open": () => void;
        /**
         * The current selection in the workspace has changed
         */
        "view:selection-changed": (selection: {
            nodes?: nodes.BaseNode;
            links?: nodes.Link[];
            link?: nodes.Link
        }) => void;
        /**
         * The workspace has switched to a different tab
         */
        "workspace:change": (change: { old: nodes.UID; workspace: nodes.UID }) => void;
        /**
         * The workspace has been cleared - this happens when switching projects
         */
        "workspace:clear": () => void;
        /**
         * The workspace has been closed
         */
        "workspace:close": (workspace: { workspace: nodes.UID; }) => void;
        /**
         * The dirty state of the editor has changed.
         */
        "workspace:dirty": (dirty: { dirty: boolean; }) => void;
        /**
         * A tab has been hidden.
         */
        "workspace:hide": (hidden: { workspace: nodes.UID; }) => void;
        /**
         * A previously hidden tab has been shown.
         */
        "workspace:show": (shown: { workspace: nodes.UID; }) => void;
    }
}

export declare namespace history {
    /**
     * Represent an History event
     */
    type HistoryEvent =
        | AddEvent
        | DeleteEvent
        | EditEvent
        | MoveEvent
        | MultiEvent
        | ReorderEvent
        | ReplaceEvent
        | CreateSubflowEvent
        | DeleteSubflowEvent
        | AddToGroupEvent
        | CreateGroupEvent
        | UngroupEvent
        | RemoveFromGroupEvent;

    /**
     * Represents the type of a History event.
     */
    type HistoryType =
        | "add"
        | "delete"
        | "edit"
        | "move"
        | "multi"
        | "reorder"
        | "replace"
        | "createSubflow"
        | "deleteSubflow"
        | "addToGroup"
        | "createGroup"
        | "ungroup"
        | "removeFromGroup";

    interface BaseEvent {
        /**
         * The history event type
         */
        t: HistoryType;
        /**
         * Whether the workspace is dirty
         */
        dirty: boolean;
        /**
         * A called after the undo/redo event
         */
        callback?: (event: HistoryEvent) => void;
    }

    /**
     * Represents an event for adding elements to the history.
     */
    interface AddEvent extends BaseEvent {
        t: "add";
        /**
         * An array with added groups
         */
        groups?: nodes.Group[];
        /**
         * An array with added junctions
         */
        junctions?: nodes.Junction[];
        /**
         * An array with added links
         */
        links?: nodes.Link[];
        /**
         * An array with added node ids
         */
        nodes?: nodes.UID[];
        /**
         * An array with removed links
         */
        removedLinks?: nodes.Link[];
        subflow?: {
            id: string;
            changed?: boolean;
            instances: nodes.BaseNode[];
        };
        /**
         * An array with added subflows (tabs)
         */
        subflows?: nodes.Subflow[];
        /**
         * An array with added workspaces
         */
        workspaces?: nodes.Workspace[];
    }

    /**
     * Represents an event for adding nodes to a group.
     */
    interface AddToGroupEvent extends BaseEvent {
        t: "addToGroup";
        /**
         * The group in which remove nodes
         */
        group: nodes.Group;
        /**
         * An array of nodes or one node to remove from the group
         */
        nodes?: nodes.BaseNode[] | nodes.BaseNode;
        /**
         * Either to re-add to parent group
         */
        reparent?: boolean;
    }

    /**
     * Represents an event for creating a group.
     */
    interface CreateGroupEvent extends BaseEvent {
        t: "createGroup";
        /**
         * An array with groups to remove
         */
        groups?: nodes.Group[];
    }

    /**
     * Represents an event for creating a subflow.
     */
    interface CreateSubflowEvent extends BaseEvent {
        t: "createSubflow";
        /**
         * The ID of the active workspace
         */
        activeWorkspace: nodes.UID;
        /**
         * An array with added links (during conversion to Subflow - links inside the subflow)
         */
        links?: nodes.Link[];
        /**
         * An array with subflow node IDs
         */
        nodes?: nodes.UID[];
        /**
         * An array with removed links (during conversion to Subflow - links from active workspace)
         */
        removedLinks?: nodes.Link[];
        /**
         * The subflow created to delete
         */
        subflow: {
            subflow: nodes.Subflow;
            offsetX?: number;
            offsetY?: number;
        };
    }
    
    /**
     * Represents an event for deleting elements from the history.
     */
    interface DeleteEvent extends BaseEvent {
        t: "delete";
        /**
         * An object with changes.
         * The key is the node ID and the value is an object with the changes
         */
        changes?: Record<nodes.UID, object>;
        /**
         * An array with created links
         */
        createdLinks?: nodes.Link[];
        /**
         * An array with removed groups
         */
        groups?: nodes.Group[];
        /**
         * An array with removed junctions
         */
        junctions?: nodes.Junction[];
        /**
         * An array with removed links
         */
        links?: nodes.Link[];
        /**
         * An array with removed nodes
         */
        nodes?: nodes.BaseNode[];
        subflow?: {
            id?: nodes.UID;
            instances?: nodes.BaseNode[];
            status?: string;
        };
        /**
         * An array with removed subflow input
         */
        subflowInputs?: nodes.SubflowNode[];
        /**
         * An array with removed subflow outputs
         */
        subflowOutputs?: nodes.SubflowNode[];
        /**
         * An array with removed subflows (tabs)
         */
        subflows?: nodes.Subflow[];
        /**
         * An array with removed workspace
         */
        workspaces?: nodes.Workspace[];
    }

    /**
     * Represents an event for deleting a subflow.
     */
    interface DeleteSubflowEvent extends BaseEvent {
        t: "deleteSubflow";
        /**
         * The id of the active workspace
         */
        activeWorkspace: nodes.UID;
        /**
         * An array with added links (during undo conversion to Subflow - links from active workspace)
         */
        createdLinks?: nodes.Link[];
        /**
         * An array with removed links (during undo conversion to Subflow - links inside the subflow)
         */
        links?: nodes.Link[];
        /**
         * An array with nodes to move to the subflow to create
         */
        movedNodes?: nodes.BaseNode[];
        /**
         * The deleted subflow to create
         */
        subflow: {
            subflow: nodes.Subflow;
            offsetX?: number;
            offsetY?: number;
        };
        /**
         * An array with subflow nodes (redo conversion to subflow)
         */
        subflows?: nodes.Subflow[];
    }

    /**
     * Represents an event for editing a node.
     */
    interface EditEvent extends BaseEvent {
        t: "edit";
        /**
         * The changed node state before modifications
         */
        changed: boolean;
        /**
         * An object with previous node properties value
         */
        changes: object;
        /**
         * An array with links to create (redo)
         */
        createdLinks?: nodes.Link[];
        /**
         * An array with removed links
         */
        links?: nodes.Link[];
        /**
         * The current node/subflow
         */
        node: nodes.BaseNode | nodes.Subflow;
        outputMap?: object;
        /**
         * Subflow properties
         */
        subflow?: {
            instances?: nodes.BaseNode[];
            inputCount?: number;
            outputCount?: number;
            status?: string;
        };
    }
    
    /**
     * Represents an event for moving nodes.
     */
    interface MoveEvent extends BaseEvent {
        t: "move";
        /**
         * The group in which the nodes were added
         */
        addToGroup?: nodes.Group;
        links?: nodes.Link[];
        /**
         * An array with nodes moved
         */
        nodes: { n: nodes.BaseNode; ox: number; oy: number; dx: number; dy: number }[];
        removedLinks?: nodes.Link[];
        /**
         * The group in which the nodes were removed
         */
        removeFromGroup?: nodes.Group;
    }
    
    /**
     * Represents an event for multiple sub-events.
     */
    interface MultiEvent extends BaseEvent {
        t: "multi";
        /**
         * An array with sub-events
         */
        events: HistoryEvent[];
    }

    /**
     * Represents an event for removing nodes from a group.
     */
    interface RemoveFromGroupEvent extends BaseEvent {
        t: "removeFromGroup";
        /**
         * The group in which add nodes
         */
        group: nodes.Group;
        /**
         * An array of nodes or one node to add to the group
         */
        nodes?: nodes.BaseNode[] | nodes.BaseNode;
        /**
         * Either to re-add to parent group
         */
        reparent?: boolean;
    }
    
    /**
     * Represents an event for reordering nodes or workspaces.
     */
    interface ReorderEvent extends BaseEvent {
        t: "reorder";
        nodes?: { from: string; to: string; z: string };
        workspaces?: {
            from: nodes.UID[];
            to: nodes.UID[];
        };
    }

    /**
     * Represents a replacement event (complete or incomplete).
     */
    type ReplaceEvent = CompleteReplaceEvent | IncompleteReplaceEvent;

    /**
    * Represents a complete replacement event.
    */
    interface CompleteReplaceEvent extends BaseEvent {
        t: "replace";
        /**
         * An object with a node id as key and the node changed property as value
         */
        changed: Record<string, boolean>;
        /**
         * Either the {@link ReplaceEvent.config} property contains the complete flows
         */
        complete: true;
        /**
         * An array with the complete flows
         */
        config: nodes.BaseNode[];
        /**
         * An object with a node ID as key and the node moved property as value
         */
        moved: Record<nodes.UID, boolean>;
        /**
         * A revision version
         */
        rev: string;
    }
    
    /**
    * Represents an incomplete replacement event.
    */
    interface IncompleteReplaceEvent extends BaseEvent {
        t: "replace";
        /**
         * Either the {@link ReplaceEvent.config} property contains the complete flows
         */
        complete?: false;
        /**
         * An array with config nodes and/or subflow definitions to replace.
         */
        config: nodes.BaseNode[];
    }

    /**
     * Represents an event for ungrouping nodes.
     */
    interface UngroupEvent extends BaseEvent {
        t: "ungroup";
        /**
         * An array with groups to create
         */
        groups?: nodes.Group[];
    }
}

export declare namespace i18n {
    type I18nT = (id: string, tplStrs?: Record<string, string | number>) => string;
}

export declare namespace notifications {
    type NotificationType = "warning" | "compact" | "success" | "error";
    interface NotificationOptions {
        fixed?: boolean;
        modal?: boolean;
        timeout?: number;
        type?: NotificationType;
        width?: number;
        buttons?:
            {
                class?: string;
                text: string;
                click: (event: JQuery.Event) => void;
            }[];
    }
    interface NotificationElement extends HTMLDivElement {
        readonly options?: NotificationOptions;
        close(): void;
        /** @internal */
        hideNotification(): void;
        /** @internal */
        showNotification(): void;
        update(msg: string | JQuery, options?: object): void;
        update(msg: string | JQuery, timeout?: number): void;
    }
}

export declare namespace plugins {
    /**
     * @link https://nodered.org/docs/api/ui/themes
     */
    interface PluginDefinition {
        module: string;
        /**
         * Called by {@link Plugins.registerPlugin}.
         */
        onadd?: () => void;
        type?: string;
    }
    interface PluginModule {
        id: string;
        local: boolean;
        name: string;
        pending_version?: string;
        plugin: true;
        sets: Record<string, PluginSet>;
        version: string;
    }
    interface PluginSet {
        editor: boolean;
        enabled: boolean;
        id: string;
        local: boolean;
        module: string;
        name: string;
        plugins: { id: string, module: string, type?: string }[];
        runtime: boolean;
        version: string;
    }
}

export declare namespace widgets {
    interface AutoCompleteOptions {
        /**
         * A function that is called when the input value changes that should
         * return a list of possible completions.
         * @param value The current value of the <input>
         */
        search: (value: string) => Array<{ value: string; label: string | JQuery }>;
        /**
         * A function that is called when the input value changes that should
         * call `done` with a list of possible completions. `done` must be called.
         * @param value The current value of the <input>
         * @param done A callback function that will be called with the completions.
         */
        search: (value: string, done: (result?: Array<{ value: string; label: string | JQuery }>) => void) => void;
    }

    interface CheckboxSetOptions {
        parent?: JQuery;
    }

    interface ToggleButtonOptions {
        /**
         * The base css class to apply, default "red-ui-button" (alternative eg "red-ui-sidebar-header-button")
         */
        baseClass?: string;
        /**
         * Additional classes to apply to the button - eg "red-ui-button-small"
         */
        class?: string;
        /**
         * The icon for "enabled" state, default "fa-check-square-o"
         */
        enabledIcon?: string;
        /**
         * The label for "enabled" state, default "Enabled" ("editor:workspace.enabled")
         */
        enabledLabel?: string;
        /**
         * The icon for "disabled" state, default "fa-square-o"
         */
        disabledIcon?: string;
        /**
         * The label for "disabled" state, default "Disabled" ("editor:workspace.disabled")
         */
        disabledLabel?: string;
        /**
         * If true, the button will show "enabled" when the checkbox is not selected and vice versa.
         */
        invertState?: boolean;
    }

    interface TreeListData {
        /**
         * Whether to display a checkbox for the item.
         */
        checkbox?: boolean;
        /**
         * Prevent a parent item from being collapsed. Default true.
         */
        collapsible?: boolean;
        /**
         * An array of child items, or a function that calls the `done` callback with an array of child items.
         */
        children?: TreeListData[] | ((done: (children: TreeListData[]) => void, item: TreeListData) => void);
        /**
         * Don't build any UI elements for the item's children until it is expanded by the user.
         */
        deferBuild?: boolean;
        /**
         * Custom DOM element to use for the item. Ignored if `label` is set.
         */
        element?: HTMLElement | JQuery;
        /**
         * Whether to show the child items by default.
         */
        expanded?: boolean;
        /**
         * Icon for the item.
         */
        icon?: string;
        /**
         * Label for the item.
         */
        label?: string;
        /**
         * Radio group name. If present, display radio box using group-name to set radio group.
         */
        radio?: string;
        /**
         * Whether the item is selected or not.
         */
        selected?: boolean;
        /**
         * A sub-label for the item.
         */
        sublabel?: string;
    }

    interface TreeListItem extends TreeListData {
        /**
         * The parent item in the tree, or undefined if this is a root item.
         */
        parent?: TreeListItem;
        /**
         * The depth of the item in the tree (0 == root).
         */
        depth: number;
        /**
         * TreeList-specific properties and methods.
         */
        treeList: {
            /**
             * The container element for this item.
             */
            container: HTMLElement | JQuery;
            /**
             * The label element for this item.
             */
            label: HTMLElement | JQuery;
            /**
             * The editableList instance this item is in.
             */
            parentList: JQuery;
            /**
             * Removes the item from the tree.
             * @param detach If true, detaches the element to preserve event handlers.
             */
            remove(detach?: boolean): void;
            /**
             * Turns an element with children into a leaf node, removing UI decoration.
             * @param detachChildElements If true, detaches children with custom elements to preserve event handlers.
             */
            makeLeaf(detachChildElements?: boolean): void;
            /**
             * Turns an element into a parent node, adding UI decoration.
             * @param children Optional children to add as child nodes.
             */
            makeParent(children?: TreeListItem[]): void;
            /**
             * Adds a child item at the specified position.
             * @param newItem The new child item to insert.
             * @param position The position to insert at.
             * @param select If true, selects the item after adding.
             */
            insertChildAt(newItem: TreeListItem, position: number, select?: boolean): void;
            /**
             * Appends a child item.
             * @param newItem The new child item to add.
             * @param select If true, selects the item after adding.
             */
            addChild(newItem: TreeListItem, select?: boolean): void;
            /**
             * Expands the parent item to show children.
             * @param done Optional callback when expansion is complete.
             */
            expand(done?: () => void): void;
            /**
             * Collapses the parent item to hide children.
             */
            collapse(): void;
            /**
             * Sorts the children using the provided sort function.
             * @param sortFunction The function to sort children.
             */
            sortChildren(sortFunction: (a: TreeListItem, b: TreeListItem) => number): void;
            /**
             * Replaces the custom element for the item.
             * @param element The new element to use.
             */
            replaceElement(element: HTMLElement | JQuery): void;
        };
    }

    interface TreeListOptions {
        /**
         * Automatically select items when navigating with keyboard.
         * Default true. If the list has checkboxed items, you probably want to set this to false.
         */
        autoSelect?: boolean;
        /**
         * Initial items to display in tree
         */
        data: TreeListData[];
        /**
         * If true, .selected will return an array of results; otherwise, returns the first selected item.
         */
        multi?: boolean;
        /**
         * Whether individual items can be selected. Default true.
         */
        selectable?: boolean;
        /**
         * If 'sortable' is set, then setting this to false prevents items being sorted to the top level of the tree.
         */
        rootSortable?: boolean;
        /**
         * Enable sorting. Boolean or string. (TODO: see editableList)
         */
        sortable?: boolean | string;
    }

    interface SearchBoxOptions {
        /**
         * Delay, in ms, after a keystroke before firing change event
         */
        delay: number;
        /**
         * The minimum length of text before firing a change event
         */
        minimumLength: number;
    }

    /** @link https://nodered.org/docs/api/ui/typedInput/#options-types */
    type DefaultTypedInputType =
        | "msg"
        | "flow"
        | "global"
        | "str"
        | "num"
        | "bool"
        | "json"
        | "bin"
        | "re"
        | "date"
        | "jsonata"
        | "env";

    /** @link https://nodered.org/docs/api/ui/typedInput/#types-typedefinition */
    interface TypedInputTypeDefinition {
        /**
         * If set, enable autoComplete on the input, using this function to get completion suggestions.
         * This option cannot be used with {@link options}, {@link hasValue}=false or {@link valueLabel}.
         */
        autoComplete?: (value: string) => Array<{ value: string; label: string | JQuery }>;
        autoComplete?: (value: string, done: (result?: Array<{ value: string; label: string | JQuery }>) => void) => void;
        /** Set to false if there is no value associated with the type. */
        hasValue?: boolean;
        /** An icon to display in the type menu */
        icon?: string;
        /** A label to display in the type menu */
        label?: string;
        /** If {@link options} is set, this can enable multiple selection of them. */
        multiple?: boolean;
        /**
         * If the type has a fixed set of values, this is an array of string options for the value.
         * For example, ["true","false"] for the boolean type.
         */
        options?: string[] | Array<{ value: string; label: string }>;
        /** A function to validate the value for the type. */
        validate?: ((value: string) => boolean) | RegExp;
        validate?: ((value: string, opt: {}) => string | boolean) | RegExp;
        /** The identifier for the type */
        value: string;
        /**
         * A function that generates the label for a given value.
         * @param container the DOM element the label should be constructed in
         * @param value The value of the type
         */
        valueLabel?: (container: JQuery, value: string) => void;
    }

    /** @link https://nodered.org/docs/api/ui/typedInput/#options */
    interface TypedInputOptions {
        /** If defined, sets the default type of the input if {@link typeField} is not set. */
        default?: TypedInputType | string;
        /** Sets the list of types the element will offer. */
        types: Array<TypedInputType | TypedInputTypeDefinition>;
        /**
         * In some circumstances it is desirable to already have an <input> element to store the type value of the typedInput.
         * This option allows such an existing element to be provided. As the type of the typedInput is changed, the value
         * of the provided input will also change.
         */
        typeField?: JQuery.Selector | JQuery;
    }

    /** @link https://nodered.org/docs/api/ui/autoComplete */
    interface AutoComplete extends JQuery {
        (options: AutoCompleteOptions): this;
        /**
         * Removes auto-complete functionality from the <input>.
         */
        (action: "destroy"): void;
    }
    interface CheckboxSet extends JQuery {
        (options: CheckboxSetOptions): this;
        (action: "addChild", child: JQuery): void;
        (action: "disable"): void;
        (action: "removeChild", child: JQuery): void;
        (action: "state", state: boolean | null, supressEvent?: boolean, suppressParentUpdate?: boolean): void;
        (action: "updateChild"): void;
    }
    /** @link https://nodered.org/docs/api/ui/editableList */
    interface EditableList extends JQuery {
        //TODO
        (): this;
    }
    /** @link https://nodered.org/docs/api/ui/searchBox */
    interface SearchBox extends JQuery {
        (options: SearchBoxOptions): this;
        /**
         * Triggers a change event on the search input.
         */
        (action: "change"): void;
        /**
         * Sets or clears a sub-label on the input. This can be used to provide
         * a feedback on the number of matches, or number of available entries to search.
         * The standard pattern to follow is:
         *   - if the search box is empty, set it to the number of available items: "300"
         *   - if the search box is not empty, set it to the number of matching items,
         *     as well as the number of available items: "120 / 300"
         * If value is `null`, `undefined` or `blank`, the count field is hidden.
         */
        (action: "count", value?: null | string): void;
        /**
         * Gets the current value of the search input.
         */
        (action: "value"): string;
        /**
         * Sets the current value of the search input.
         */
        (action: "value", value: string): void;
    }
    interface ToogleButton extends JQuery {
        (options: ToggleButtonOptions): this;
    }
    /** @link https://nodered.org/docs/api/ui/treeList */
    interface TreeList extends JQuery {
        (options: TreeListOptions): this;
        (action: "clearSelection"): void;
        /**
         * Returns the data the treeList is displaying.
         * If any items had the `selected` property set on them, its value will reflect the current checkbox state.
         */
        (action: "data"): TreeListData[];
        /**
         * Sets the data to be displayed by the list.
         */
        (action: "data", items: TreeListData[]): void;
        /**
         * Removes all items from the list.
         */
        (action: "empty"): void;
        (action: "filter", filter: (item: TreeListItem) => boolean): number;
        (action: "get", id: string): TreeListItem | null;
        (action: "reveal", item: string | TreeListItem): void;
        (action: "select", item: TreeListItem | TreeListItem[], triggerEvent?: boolean, deselectExisting?: boolean): void;
        (action: "selected"): TreeListItem | TreeListItem[] | undefined;
        (action: "show", item: string | TreeListItem, done?: () => void): void;
    }
    /** @link https://nodered.org/docs/api/ui/typedInput */
    interface TypedInput extends JQuery {
        (options: TypedInputOptions): this;
        /**
         * Disables the typedInput.
         */
        (action: "disable", value?: boolean): void;
        /**
         * Gets the disabled state of the typedInput.
         */
        (action: "disabled"): boolean;
        /**
         * Enables the typedInput.
         */
        (action: "enable"): void;
        /**
         * Focuses the typedInput.
         */
        (action: "focus"): void;
        /**
         * Hides the typedInput.
         */
        (action: "hide"): void;
        /**
         * Shows the typedInput.
         */
        (action: "show"): void;
        /**
         * Gets the selected type of the typedInput.
         */
        <T extends string = DefaultTypedInputType>(action: "type"): T;
        /**
         * Sets the selected type of the typedInput.
         */
        <T extends string = DefaultTypedInputType>(action: "type", value: T): void;
        /**
         * Sets the list of types offered by the typedInput.
         */
        (action: "types", value: Array<DefaultTypedInputType | TypedInputTypeDefinition>): void;
        /**
         * Triggers manually a revalidation of the typedInput’s type/value.
         * This occurs automatically whenever the type or value change.
         */
        (action: "validate"): boolean;
        (action: "validate", options: { returnErrorMessage: boolean; }): string | boolean;
        /**
         * Gets the value of the typedInput.
         */
        (action: "value"): string;
        /**
         * Sets the value of the typedInput.
         */
        (action: "value", value: string): void;
        /**
         * Sets the width of the typedInput. This must be used in place of the standard
         * ```jQuery.width()``` function as it ensures the component resizes properly.
         */
        (action: "width", value: string | number): void;
    }
}

export interface ActionList {
    /** @internal */
    init(): void;
    /**
     * Hides the action list dialog.
     */
    hide(): void;
    /**
     * Shows the action list dialog.
     * @param filter The filter to apply to the list
     */
    show(filter?: string): void;
}

export interface Actions {
    add(name: string, handler: (...args: any[]) => void, options?: object): void;
    get(name: string): (...args: any[]) => void;
    /**
     * Used to get or generate and translate action label
     */
    getActionLabel(name: string): string;
    invoke(name: string, ...args: any[]): void;
    list(): { id: string; scope?: string; key?: string; user: boolean; label?: string; options?: object }[];
    remove(name: string): void;
}

export interface Comms {
    /** @internal */
    connect(): void;
    /** @internal */
    on(event: string, listener: (...args: any[]) => void): void;
    /** @internal */
    off(event: string, listener: (...args: any[]) => void): void;
    /**
     * Sends data to the runtime
     */
    send(topic: string, data: any): void;
    subscribe(topic: string, callback: (topic: string, data: any) => void): void;
    unsubscribe(topic: string, callback: (topic: string, data: any) => void): void;
}

export interface Editor {
    /**
     * Returns a list of all TypeEditor registered by calling {@link registerTypeEditor}.
     */
    readonly customEditTypes: editor.TypeEditorDefinition[];
    /** @internal */
    init(): void;
    /** @internal */
    buildEditForm(
        container: JQuery<HTMLElement>,
        formId: string,
        type: string,
        ns: string,
        node: never
    ): JQuery<HTMLElement>;
    /**
     * Create a editor ui component
     * @param options - the editor options
     */
    createEditor(options: editor.EditorOptions): AceAjax.Editor;
    /**
     * Opens the edit box for the given **node**.
     * Must be a regular node!
     * @param node The node to edit
     * @param defaultTab
     */
    edit(node: nodes.Node, defaultTab?: any): void;
    /**
     * Opens the edit box for the given **config node**.
     * @param name name of the property that holds this config node or empty
     * @param type type of config node
     * @param id id of config node to edit.`_ADD_` for a new one
     * @param prefix the input prefix of the parent property
     * @param editContext the node that was being edited that triggered editing this node
     */
    editConfig(
        name: string,
        type: string,
        id: string,
        prefix?: editor.ConfigNodePrefix,
        editContext?: nodes.Node
    ): void;
    /**
     * Opens the edit box for the given **flow** (workspace).
     * @param workspace The flow to edit
     * @param defaultTab
     */
    editFlow(workspace: nodes.Workspace, defaultTab?: any): void;
    /**
     * Opens the edit box for the given **group**.
     * @param group The group node to edit
     * @param defaultTab
     */
    editGroup(group: nodes.Group, defaultTab?: any): void;
    /**
     * Opens the edit box for the given **subflow**.
     * @param subflow The subflow to edit
     * @param defaultTab
     */
    editSubflow(subflow: nodes.Subflow, defaultTab?: any): void;

    /**
     * Opens a Buffer edit box.
     */
    editBuffer(options: editor.BufferOptions): void;
    /**
     * Opens a Expression edit box.
     */
    editExpression(options: editor.ExpressionOptions): void;
    /**
     * Opens a JavaScript edit box.
     */
    editJavaScript(options: editor.JavaScriptOptions): void;
    /**
     * Opens a JSON edit box.
     */
    editJSON(options: editor.JSONOptions): void;
    /**
     * Opens a Markdown edit box.
     */
    editMarkdown(options: editor.MarkdownOptions): void;
    /**
     * Opens a Text edit box.
     */
    editText(options: editor.TextOptions): void;

    /**
     * Generates a consistent but unique ID for saving and restoring the code editors view state.
     */
    generateViewStateId(source: string, thing?: object, suffix?: string): string | false;
    /**
     * Returns a list of all modified objects (all open edit boxes)
     */
    getEditStack(): object[];
    /**
     * Creates a config-node select box for this property
     * @param node the node being edited
     * @param property the name of the node property
     * @param type the type of the config-node
     * @param prefix the prefix to use in the input element ids
     * @param filter a function to filter the list of config nodes
     * @param env the environment variable object (only used for subflow env vars)
     */
    prepareConfigNodeSelect(
        node: nodes.BaseNode,
        property: string,
        type: string,
        prefix: editor.ConfigNodePrefix,
        filter?: (configNode: nodes.ConfigNode) => boolean,
        env?: object
    ): void;
    /** @internal */
    registerEditPane(type: string, definition: editor.PaneDefinition, filter?: any)
    /**
     * Register a type editor.
     * @param type the type name
     * @param definition the editor definition
     */
    registerTypeEditor(type: string, definition: editor.TypeEditorDefinition): void;
    showIconPicker(
        container: JQuery,
        backgroundColor: string,
        iconPath: object,
        faOnly: boolean,
        done: (res: string) => void,
    ): void;
    /**
     * Show a type editor.
     * @param type - the type to display
     * @param options - options for the editor
     */
    showTypeEditor(type: string, options: editor.TypeEditorOptions): void;
    /**
     * Called when the node's properties have changed.
     * Marks the node as dirty and needing a size check.
     * Removes any links to non-existant outputs.
     * @param node the node that has been updated
     * @param outputMap (optional) a map of old->new port numbers if wires should be moved
     * @returns the links that were removed due to this update
     * @internal
     */
    updateNodeProperties(node: nodes.BaseNode, outputMap?: Record<string, string>): nodes.Link[];
    /**
     * Validates each property of a node by calling {@link nodes.PropertyDefinition.validate validate}.
     * @param node - the node being validated
     */
    validateNode(node: nodes.BaseNode): boolean;
}

/** @internal */
interface EventLog {
    init(): void;
    show(): void;
    log(id: any, payload: { ts: number; data?: string; type?: string; }): void;
    startEvent(name: string): void;
}

export interface Events<L extends events.ListenerSignature<L> = events.Events> {
    /**
     * Registers a new handler for the given event.
     * @param event The name of the event to listen
     * @param listener The handler function to add
     * @example
     * RED.events.on("nodes:add", function (node) {
     *   console.log("A node has been added to the workspace!")
     * });
     * @link https://nodered.org/docs/api/ui/events/#methods-on
     */
    on<U extends keyof L>(event: U, listener: L[U]): void;
    /**
     * Removes a previously registered event handler.
     * @param event The name of the event
     * @param listener The handler function to remove
     * @link https://nodered.org/docs/api/ui/events/#methods-off
     */
    off<U extends keyof L>(event: U, listener: L[U]): void;
    /**
     * Emits a event with the supplied arguments
     * @param event The name of the event
     * @param args The argument list
     */
    emit<U extends keyof L>(event: U, ...args: Parameters<L[U]>): void;
}

export interface History {
    /**
     * @internal
     */
    markAllDirty(): void;
    /**
     * Returns a list with undo events.
     */
    list(): history.HistoryEvent[];
    /**
     * Returns a list with redo events.
     */
    listRedo(): history.HistoryEvent[];
    /**
     * Returns the size of the list with redo events.
     */
    depth(): number;
    /**
     * Pushes an event to the History. This event can be undo by
     * calling {@link History.pop pop}().
     * @param event The event to push
     */
    push(event: history.HistoryEvent): void;
    /**
     * Called to undo an event.
     * Takes the last event of the undo list, do undo event and adds
     * the redo event generated to the redo list.
     */
    pop(): void;
    /**
     * Returns the last event of undo list.
     */
    peek(): history.HistoryEvent;
    /**
     * Replaces the last event of undo list by the event given
     * in parameter.
     * @param event The event to replace
     */
    replace(event: history.HistoryEvent): void;
    /**
     * Clears the undo list and redo list.
     */
    clear(): void;
    /**
     * Called to redo an event.
     * Takes the last event of the redo list, do redo event and adds
     * the undo event generated to the undo list.
     */
    redo(): void;
}

export interface MultiPlayer {
    /** @internal */
    init(): void;
}

export interface Nodes {
    //readonly registry: nodes.Registry;

    /**
     * Cleans all nodes and workspaces. Returns to a clean state before the first import.
     */
    clear(): void;
    /**
     * Get the dirty state of the editor. `Dirty` means there are undeployed changes.
     */
    dirty(): boolean;
    /**
     * Defines the dirty state of the editor. Triggers the {@link events.Events workspace:dirty} event.
     * @param dirty 
     */
    dirty(dirty: boolean): void;
    /**
     * Generates a unique node ID.
     */
    id(): nodes.UID;
    version(): string;
    version(version: string): void;

    node(id: nodes.UID): nodes.BaseNode | null;
    add(node: nodes.NodeObject): nodes.BaseNode;
    
    remove(id: nodes.UID): { links: nodes.Link[]; nodes: nodes.BaseNode[] };

    group(id: nodes.UID): nodes.Group | null;

    junction(id: nodes.UID): nodes.Junction | null;

    getNodeLinks(id: nodes.UID, portType: 0 | 1): nodes.Link[];
    /** @deprecated */
    getNodeLinks(link: nodes.Link, portType: 0 | 1): nodes.Link[];

    subflow(id: nodes.UID): nodes.Subflow | null;
    /**
     * Add a Subflow to the Workspace
     * @param subflow The Subflow to add
     * @param updateName Whether to update the name.
     */
    addSubflow(subflow: nodes.NodeObject<nodes.Subflow>, updateName?: boolean): void;
    removeSubflow(subflow: nodes.Subflow): void;
    subflowContains(subflowId: nodes.UID, nodeId: nodes.UID): boolean;

    workspace(id: nodes.UID): nodes.Workspace | null;
    addWorkspace(workspace: nodes.NodeObject<nodes.Workspace>, targetIndex?: number): void;
    removeWorkspace(id: nodes.UID): {
        nodes: nodes.BaseNode[];
        links: nodes.Link[];
        groups: nodes.Group[];
        junctions: nodes.Junction[]
    };
    getWorkspaceOrder(): nodes.UID[];
    setWorkspaceOrder(order: nodes.UID[]): void;

    eachConfig(callback: (node: nodes.ConfigNode) => void | false): void;
    eachGroup(callback: (node: nodes.Group) => void | false): void;
    eachJunction(callback: (node: nodes.Junction) => void | false): void;
    eachLink(callback: (node: nodes.Link) => void | false): void;
    eachNode(callback: (node: nodes.BaseNode) => void | false): void;
    eachSubflow(callback: (node: nodes.Subflow) => void | false): void;
    eachWorkspace(callback: (node: nodes.Workspace) => void | false): void;

    import(nodes, options): {
        nodes: nodes.BaseNode[];
        links: {
            source: nodes.BaseNode;
            sourcePort: number;
            target: nodes.BaseNode;
        }[];
        groups: nodes.Group[];
        junctions: nodes.Junction[];
        workspaces: nodes.Workspace[];
        subflows: nodes.Subflow[];
        missingWorkspace: nodes.Workspace;
        removedNodes: nodes.BaseNode[] | undefined;
    } | undefined;

    originalFlow(): nodes.NodeObject[];
    /** @internal */
    originalFlow(flow: nodes.NodeObject[]): void;

    /**
     * Converts a node to an exportable JSON Object
     */
    convertNode(node: nodes.BaseNode, exportCreds: boolean): nodes.NodeObject;
    /**
     * Converts the current node selection to an exportable JSON Object
     */
    createExportableNodeSet(
        set: object[],
        exportedIds?: object,
        exportedSubflows?: object,
        exportedConfigNodes?: object,
    ): Array<nodes.NodeObject>;
    /**
     * Converts the complete flow to an exportable JSON Object
     */
    createCompleteNodeSet(options?: { credentials?: boolean, dimensions?: boolean }): Array<nodes.NodeObject>;
    updateConfigNodeUsers(node: nodes.Node, options?: { action?: "add" | "remove", emitEvent?: boolean }): void;
}

export interface Notifications {
    /**
     * If set to true, all notifications will be hidden.
     * @internal
     */
    hide?: boolean;
    /** @internal */
    init(): void;
    /**
     * @example
     * // Plain information notification
     * RED.notify("Hello World");
     * // Warning notification for 10 seconds
     * RED.notify("Something has happened", { type: "warning", timeout: 10000 });
     * // Notification with buttons
     * let myNotification = RED.notify("This is the message to display", {
     *   modal: true,
     *   fixed: true,
     *   type: "warning",
     *   buttons: [
     *     {
     *        text: "cancel",
     *        click: function (e) {
     *          myNotification.close();
     *        }
     *     },
     *     {
     *        text: "okay",
     *        class: "primary",
     *        click: function (e) {
     *          myNotification.close();
     *        }
     *     }
     *   ]
     * });
     */
    notify(msg: string | JQuery, options?: notifications.NotificationOptions): notifications.NotificationElement;
    notify(msg: string | JQuery, type?: notifications.NotificationType): notifications.NotificationElement;
    /** @deprecated please use options instead */
    notify(msg: string | JQuery, type?: notifications.NotificationType, fixed?: boolean, timeout?: number): notifications.NotificationElement;
}

export interface Plugins {
    /**
     * Adds the plugin module to the module lists.
     * @internal
     */
    addPlugin(plugin: plugins.PluginModule): void;
    /**
     * Gets the plugin module from the module lists.
     * @internal
     */
    getModule(module: string): plugins.PluginModule | null;
    /**
     * Gets the plugin definition from the registry.
     */
    getPlugin(id: string): plugins.PluginDefinition | null;
    /**
     * Gets a list of plugin definitions for the given type.
     */
    getPluginsByType(id: string): plugins.PluginDefinition[];
    /**
     * Adds the plugin definition to the registry.
     */
    registerPlugin(id: string, definition: plugins.PluginDefinition): void;
    /**
     * Calls {@link addPlugin} for each element of the list.
     * @internal
     */
    setPluginList(list: plugins.PluginModule[]): void;
}

export interface Runtime {
    /** @internal */
    init(): void;
    readonly started: "start" | "stop" | "safe" | "";
}

// TODO: runtime settings
export interface Settings {
    /**
     * The Node-RED version
     */
    readonly version: string;
    /**
     * Gets the setting from the user or runtime settings.
     * @param key The key to the setting to search for
     * @param defaultValue The default value if undefined
     * @example
     * // Returns an object
     * RED.settings.get("editor")
     * // Return a string
     * RED.settings.get("debug.filter")
     * // Returns undefined
     * RED.settings.get("fake")
     */
    get<T = any>(key: string, defaultValue: T): T;
    get<T = any>(key: string): T | undefined;
    /**
     * Gets an item from the {@link Storage localStorage}.
     */
    getLocal(key: string): string | null;
    /** @internal */
    init(options: { apiRootUrl: string; }, done: () => void): void;
    /** @internal */
    load(done: () => void): void;
    /** @internal */
    loadUserSettings(done: () => void): void;
    refreshSettings(done: () => void): void;
    /**
     * Sets and saves the user setting
     */
    set(key: string, value: any): void;
    /**
     * Sets an item to {@link Storage localStorage}.
     */
    setLocal(key: string, value: any): void;
    /**
     * Removes and saves the user setting
     */
    remove(key: string): void;
    /**
     * Removes an item from the {@link Storage localStorage}.
     */
    removeLocal(key: string): void;
    /**
     * Gets (like {@link get}) the property from the theme settings.
     */
    theme<T = any>(property: string, defaultValue: T): T;
    theme<T = any>(property: string): T | undefined;
}

export interface SidebarConfig {
    /** @internal */
    init(): void;
    /**
     * Same as `RED.sidebar.show("config")`
     */
    show(): void;
    /**
     * Shows unused or all config nodes
     */
    show(unused: boolean): void;
    /**
     * Shows the config node with the given ID
     */
    show(id: nodes.UID): void;
    /**
     * Rebuilds the Sidebar Config content
     */
    refresh(): void;
}

export interface SidebarContext {
    /** @internal */
    init(): void;
}

export interface SidebarHelp {
    init(): void;
    /**
     * Shows the help for the given node type
     */
    show(type?: string): void;
    /**
     * Defines dynamically the tab content
     */
    set(html: string, title?: string): void;
}

export interface SidebarInfo {
    outliner: SidebarInfoOutliner;
    /** @internal */
    init(): void;
    show(): void;
    /**
     * Refreshs the {@link View.selection selection}.
     */
    refresh(): void;
    /**
     * Same as {@link clear}.
     */
    refresh(node: null): void;
    refresh(node: nodes.BaseNode | nodes.BaseNode[]): void;
    /**
     * Clears the Info tab content
     */
    clear(): void;
    /** @deprecated use {@link SidebarHelp.set} instead */
    set(html: string, title?: string): void;
}

export interface SidebarInfoOutliner {
    build(): HTMLElement;
    search(value: string): void;
    /**
     * Clears selection
     */
    select(): void;
    select(node: nodes.BaseNode | nodes.BaseNode[]): void;
    /**
     * Shows the node infos
     */
    reveal(node: nodes.BaseNode): void;
}

/**
 * Used by Projects
 * @internal
 */
interface SidebarVersionControl {
    init(utils: object): void;
    show(): void;
    refresh(full?: boolean, includeRemote?: boolean): void;
    showLocalChanges(): void;
}

export interface Sidebar {
    config: SidebarConfig;
    context: SidebarContext;
    help: SidebarHelp;
    info: SidebarInfo;
    versionControl: SidebarVersionControl;
    /** @internal */
    init(): void;
    /**
     * Adds a tab to the Sidebar
     */
    addTab(options: {
        action?: string;
        content: HTMLElement;
        enableOnEdit?: boolean;
        iconClass?: string;
        id: string;
        label: string;
        name: string;
        toolbar?: HTMLElement;
        visible?: boolean;
    }): void;
    containsTab(id: string): boolean;
    removeTab(id: string): void;
    show<T extends string = "config" | "context" | "degub" | "help" | "info">(id: T, skipShowSidebar?: boolean): void;
    toggleSidebar(state: boolean): void;
}

export interface StatusBar {
    /** @internal */
    init(): void;
    /**
     * Adds a Widget to the Status Bar
     */
    add(options: { id: string; element: HTMLElement; align?: "left" | "right" }): void;
    /** @since 4.1 */
    hide(id: string): void;
    /** @since 4.1 */
    show(id: string): void;
}

export interface Tray {
    /** @internal */
    init(): void;
    close(done?: () => void): void;
    hide(): void;
    resize(): void;
    show(options?: editor.TrayOptions): void;
}

export interface User {
    generateUserIcon(user: object): JQuery<HTMLElement>;
    hasPermission(permission: string | string[]): boolean;
    /** @internal */
    init(): void;
    login(done: () => void): void;
    login(options: { cancelable?: boolean; updateMenu?: boolean }, done: () => void): void;
    logout(): void;
}

export interface Validators {
    number(allowBlanck?: boolean): nodes.PropertyValidator;
    regex(regex: RegExp): nodes.PropertyValidator;
    /** @deprecated */
    typedInput(typeField: string, isConfigNode?: boolean): nodes.PropertyValidator;
    typedInput(options: { allowBlank?: boolean, isconfig?: boolean, typeField: string }): nodes.PropertyValidator;
}

export interface View {
    /** @internal */
    init(): void;
    /**
     * Focuses the workspace chart
     */
    focus(): void;
    /** @internal */
    state<K extends keyof typeof viewState>(state: null): typeof viewState[K];
    /** @internal */
    state<K extends keyof typeof viewState>(state: typeof viewState[K]): void;
}

export declare const viewState: {
    readonly DEFAULT: 0;
    readonly MOVING: 1;
    readonly JOINING: 2;
    readonly MOVING_ACTIVE: 3;
    readonly ADDING: 4;
    readonly EDITING: 5;
    readonly EXPORT: 6;
    readonly IMPORT: 7;
    readonly IMPORT_DRAGGING: 8;
    readonly QUICK_JOINING: 9;
    readonly PANNING: 10;
    readonly SELECTING_NODE: 11;
    readonly GROUP_DRAGGING: 12;
    readonly GROUP_RESIZE: 13;
    readonly DETACHED_DRAGGING: 14;
    readonly SLICING: 15;
    readonly SLICING_JUNCTION: 16;
};

export interface RED {
    _: i18n.I18nT;
    actionList: ActionList;
    /**
     * This API can be used to register and invoke Actions in the editor.
     * Actions are individual pieces of functionality that a user may want
     * to trigger and can be bound to keyboard shortcuts.
     * @link https://nodered.org/docs/api/ui/actions
     */
    actions: Actions;
    /**
     * This Comms API provides a real-time connection between the runtime and the editor via a WebSocket.
     * The network overhead of this connection **MUST** be kept as low as possible.
     */
    comms: Comms;
    editor: Editor;
    /** @internal */
    eventLog: EventLog;
    /**
     * The editor emits events that components can listen for so they can react as needed.
     * @link https://nodered.org/docs/api/ui/events
     */
    events: Events;
    /**
     * The History API for undo / redo history buffer
     */
    history: History;
    multiplayer: MultiPlayer;
    /**
     * The Nodes API
     */
    nodes: Nodes;
    notify: Notifications["notify"];
    /**
     * This API can be used to display notifications that pop-down from the top of the editor.
     * @link https://nodered.org/docs/api/ui/notifications
     */
    notifications: Notifications;
    plugins: Plugins;
    runtime: Runtime;
    /**
     * @link https://nodered.org/docs/api/ui/sidebar
     */
    sidebar: Sidebar;
    settings: Settings;
    state: typeof viewState;
    statusBar: StatusBar;
    tray: Tray;
    /**
     * @link https://nodered.org/docs/creating-nodes/properties#property-validation
     */
    validators: Validators;
    view: View;
}

declare global {
    /**
     * The Node-RED Editor API
     */
    var RED: RED;

    interface JQuery<TElement = HTMLElement> {
        autoComplete: widgets.AutoComplete;
        checkboxSet: widgets.CheckboxSet;
        editableList: widgets.EditableList; 
        searchBox: widgets.SearchBox;
        toggleButton: widgets.ToogleButton;
        treeList: widgets.TreeList;
        typedInput: widgets.TypedInput;
    }
}
