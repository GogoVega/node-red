/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

export declare namespace nodes {
    /**
     * The Unique Node ID:
     * A set of 16 number or lower alphabetic characters
     */
    type UID = string;

    /** Reserved name for properties that MUST NOT BE USED. */
    type ReservedProperties =
        | "changed"
        | "colorChanged"
        | "dirty"
        | "icon"
        | "id"
        | "info"
        | "inputLabels"
        | "label"
        | "moved"
        | "outputLabels"
        | "ports"
        | "reordered"
        | "selected"
        | "type"
        | "users"
        | "valid"
        | "validationErrors"
        | "wires"
        | "a"
        | "b"
        | "c"
        | "d"
        | "e"
        | "f"
        | "g"
        | "h"
        | "i"
        | "j"
        | "k"
        | "l"
        | "m"
        | "n"
        | "o"
        | "p"
        | "q"
        | "r"
        | "s"
        | "t"
        | "u"
        | "v"
        | "w"
        | "x"
        | "y"
        | "z";

    /** Name for properties that are NOT importable/exportable. */
    type NotExportedProperties =
        | "_"
        | "_config"
        | "_def"
        | "changed"
        | "colorChanged"
        | "dirty"
        | "moved"
        | "reordered"
        | "selected"
        | "users"
        | "valid"
        | "validationErrors"
        | "a"
        | "b"
        | "c"
        | "e"
        | "f"
        | "h"
        | "i"
        | "j"
        | "k"
        | "m"
        | "n"
        | "o"
        | "p"
        | "q"
        | "r"
        | "s"
        | "t"
        | "u"
        | "v"
        | "w";

    type NodeCredentials = Record<string, string>;

    /**
     * Node properties
     * @see {@link https://nodered.org/docs/creating-nodes/properties}
     */
    interface NodeProperties {
        name?: string;
        inputs?: 0 | 1;
        outputs?: number;
    }

    interface CredentialDefinition {
        /**
         * The credential label. Shown in the error badge/input popover.
         */
        label?: string;
        /**
         * The default value the credential takes. **Do not use it for legacy property**.
         */
        value?: any;
        /**
         * Whether the value must be non-empty
         */
        required?: boolean;
        validate?: PropertyValidator | undefined
        type: "text" | "password";
    }

    /**
     * Property definition
     * @see {@link https://nodered.org/docs/creating-nodes/properties#property-definitions}
     */
    interface PropertyDefinition {
        /**
         * The property label. Shown in the error badge/input popover.
         */
        label?: string;
        /**
         * The default value the property takes. **Do not use it for legacy property**.
         */
        value?: any;
        /**
         * Whether the value must be non-empty
         */
        required?: boolean;
        validate?: PropertyValidator | undefined;
        /**
         * Selector to a config node type
         */
        type?: string;
        /**
         * Defines the 'real' type for lists of nodes
         * @internal
         */
        _type?: { type: string; array: true };
    }

    type PropertyValidator = (this: BaseNode, value: string, opt: { label?: string; }) => boolean | string;

    /** This type converts a node into its exportable form */
    type NodeObject<T extends BaseNode = BaseNode> = Omit<T, NotExportedProperties> & Omit<T["credentials"], "_">;

    //type NodeInstance<TProps extends NodeProperties = {}, TCreds extends NodeCredentials = {}> = Omit<TProps, ReservedProperties> & BaseNode;

    interface BaseNode {
        _: i18n.I18nT;
        /**
         * Loaded node configuration
         * @internal
         */
        _config: object;
        /**
         * Node definition
         * @internal
         */
        _def: object;
        /** The Unique Node ID */
        id: UID;
        type: string;
        /** Whether the node configuration has changed */
        changed: boolean;
        /** The node credentials */
        credentials?: {
            /**
             * Loaded credentials
             * @internal
             */
            _?: Record<string, string>;
        };
        /**
         * The flow, subflow or group ID. If the node is a Config Node,
         * the value can be undefined to use the global config
         */
        z?: UID;
    }

    interface Node extends BaseNode {
        _def: object;
        /** Whether the node color has changed and needs to be redrawn */
        colorChanged?: true;
        /** Whether the node is disabled */
        d?: true;
        /** Whether the node needs to be redrawn */
        dirty: boolean;
        /** Whether the node is included in a group */
        g?: nodes.UID;
        /** The node height in the 'flow' space */
        h?: number;
        /** An icon from file or Font Awesome */
        icon?: string;
        /** Description of the node */
        info?: string;
        /** The input count */
        inputs: 0 | 1;
        /** A list of input labels */
        inputLabels?: string[];
        /** Show/Hide the node label */
        l?: false;
        /** The node label */
        label?: string | ((this: Node) => string);
        /** Whether the node has moved */
        moved?: true;
        /** The output count */
        outputs: number;
        /** Whether the node has been reordered */
        reordered?: true;
        /** A list of output labels */
        outputLabels?: string[];
        /** Whether the node is selected */
        selected?: true;
        /** Whether the node has a valid configuration */
        valid: boolean;
        /** A list of error messages shown in the badge */
        validationErrors: string[];
        /** The node weight in the 'flow' space */
        w?: number;
        /** A list of linked nodes */
        wires?: Array<[UID]>;
        /** The horizontal position on the canvas */
        x: number;
        /** The vertical position on the canvas */
        y: number;
        z: nodes.UID;
    }

    interface Group extends BaseNode {
        env?: object[];
    }

    interface Link extends BaseNode {
        source: BaseNode;
        sourcePort: number;
        target: BaseNode;
    }

    interface Subflow extends BaseNode {}
    interface Workspace extends BaseNode {}
    interface Junction extends BaseNode {}
}

export declare namespace events {
    type DefaultListener = {
        [k: string]: (...args: any[]) => void;
    };

    type ListenerSignature<L> = {
        [E in keyof L]: (...args: any[]) => void;
    };

    /**
     * @link https://nodered.org/docs/api/ui/events/#available-events
     */
    interface Events extends DefaultListener {
        /** @internal */
        "actionList:close": () => void;
        /** @internal */
        "actionList:open": () => void;
        /**
         * A new flow has been deployed
         */
        deploy: () => void;
        /** @internal */
        "editor:change": () => void;
        /** @internal */
        "editor:close": () => void;
        /** @internal */
        "editor:open": () => void;
        /** @internal */
        "editor:save": (node: nodes.BaseNode) => void;
        /**
         * A new flow has been added
         */
        "flows:add": (workspace: nodes.Workspace) => void;
        /**
         * A flow’s properties have been changed
         */
        "flows:change": (workspace: nodes.Workspace) => void;
        /** @internal */
        "flows:loaded": () => void;
        /**
         * A flow has been removed
         */
        "flows:remove": (workspace: nodes.Workspace) => void;
        /**
         * The flows have been reordered
         */
        "flows:reorder": (workspaces: nodes.UID[]) => void;
        /**
         * A new group has been added
         */
        "groups:add": (group: nodes.Group) => void;
        /**
         * A group’s properties have been changed
         */
        "groups:change": (group: nodes.Group) => void;
        /**
         * A new group has been removed
         */
        "groups:remove": (group: nodes.Group) => void;
        /**
         * A new junction has been added
         */
        "junctions:add": (junction: nodes.Junction) => void;
        /**
         * A junction’s properties have been changed
         */
        "junctions:change": (junction: nodes.Junction) => void;
        /**
         * A new junction has been removed
         */
        "junctions:remove": (junction: nodes.Junction) => void;
        /**
         * A new link has been added
         */
        "links:add": (link: nodes.Workspace) => void;
        /**
         * A new link has been removed
         */
        "links:remove": (link: nodes.Workspace) => void;
        /**
         * A user has logged into the editor.
         * If `adminAuth` is not configured, this event is never emitted
         */
        login: (user: string) => void;
        /**
         * The current user has logged out.
         */
        logout: () => void;
        /**
         * A new node has been added
         */
        "nodes:add": (node: nodes.BaseNode) => void;
        /**
         * A node’s properties have been changed
         */
        "nodes:change": (node: nodes.BaseNode) => void;
        /**
         * A new node has been removed
         */
        "nodes:remove": (node: nodes.BaseNode) => void;
        /**
         * Nodes have been reordered on a flow
         */
        "nodes:reorder": (z: nodes.UID, nodes: nodes.BaseNode[]) => void;
        "project:change": (change: { name: string; }) => void;
        /** @internal */
        "projects:load": (project: object) => void;
        /**
         * A module has updated to a new version
         */
        "registry:module-updated": (module: { module: string; version: string; }) => void;
        /**
         * A new Node-Set has been added to the palette
         */
        "registry:node-set-added": (set: nodes.Node) => void;
        /**
         * A Node-Set has been disabled
         */
        "registry:node-set-disabled": (set: nodes.Node) => void;
        /**
         * A Node-Set has been enabled
         */
        "registry:node-set-enabled": (set: nodes.Node) => void;
        /**
         * A Node-Set has been removed
         */
        "registry:node-set-removed": (set: nodes.Node) => void;
        /**
         * A new Node has been added to the palette
         */
        "registry:node-type-added": (type: string) => void;
        /**
         * A Node has been removed from the palette
         */
        "registry:node-type-removed": (type: string) => void;
        /**
         * A Plugin has been added
         */
        "registry:plugin-added": (name: string) => void;
        /** @internal */
        "registry:plugin-module-added": (name: string) => void;
        /** @internal */
        "runtime-state": (state: Record<string, any>) => void;
        /** @internal */
        "search:close": () => void;
        /** @internal */
        "search:open": () => void;
        /** @internal */
        "sidebar:resize": () => void;
        /**
         * A new subflow has been added
         */
        "subflows:add": (subflow: nodes.Subflow) => void;
        /**
         * A subflow’s properties have been changed
         */
        "subflows:change": (subflow: nodes.Subflow) => void;
        /**
         * A new subflow has been removed
         */
        "subflows:remove": (subflow: nodes.Subflow) => void;
        /** @internal */
        "type-search:close": () => void;
        /** @internal */
        "type-search:open": () => void;
        /**
         * The current selection in the workspace has changed
         */
        "view:selection-changed": (selection: {
            nodes?: nodes.BaseNode;
            links?: nodes.Link[];
            link?: nodes.Link
        }) => void;
        /**
         * The workspace has switched to a different tab
         */
        "workspace:change": (change: { old: nodes.UID; workspace: nodes.UID }) => void;
        /**
         * The workspace has been cleared - this happens when switching projects
         */
        "workspace:clear": () => void;
        /**
         * The workspace has been closed
         */
        "workspace:close": (workspace: { workspace: nodes.UID; }) => void;
        /**
         * The dirty state of the editor has changed.
         */
        "workspace:dirty": (dirty: { dirty: boolean; }) => void;
        /**
         * A tab has been hidden.
         */
        "workspace:hide": (hidden: { workspace: nodes.UID; }) => void;
        /**
         * A previously hidden tab has been shown.
         */
        "workspace:show": (shown: { workspace: nodes.UID; }) => void;
    }
}

export declare namespace history {
    /**
     * Represent an History event
     */
    type HistoryEvent =
        | AddEvent
        | DeleteEvent
        | EditEvent
        | MoveEvent
        | MultiEvent
        | ReorderEvent
        | ReplaceEvent
        | CreateSubflowEvent
        | DeleteSubflowEvent
        | AddToGroupEvent
        | CreateGroupEvent
        | UngroupEvent
        | RemoveFromGroupEvent;

    /**
     * Represents the type of a History event.
     */
    type HistoryType =
        | "add"
        | "delete"
        | "edit"
        | "move"
        | "multi"
        | "reorder"
        | "replace"
        | "createSubflow"
        | "deleteSubflow"
        | "addToGroup"
        | "createGroup"
        | "ungroup"
        | "removeFromGroup";

    interface BaseEvent {
        /**
         * The history event type
         */
        t: HistoryType;
        /**
         * Whether the workspace is dirty
         */
        dirty: boolean;
        /**
         * A called after the undo/redo event
         */
        callback?: (event: HistoryEvent) => void;
    }

    /**
     * Represents an event for adding elements to the history.
     */
    interface AddEvent extends BaseEvent {
        t: "add";
        /**
         * An array with added groups
         */
        groups?: nodes.Group[];
        /**
         * An array with added junctions
         */
        junctions?: nodes.Junction[];
        /**
         * An array with added links
         */
        links?: nodes.Link[];
        /**
         * An array with added node ids
         */
        nodes?: nodes.UID[];
        /**
         * An array with removed links
         */
        removedLinks?: nodes.Link[];
        subflow?: {
            id: string;
            changed?: boolean;
            instances: nodes.BaseNode[];
        };
        /**
         * An array with added subflows (tabs)
         */
        subflows?: nodes.Subflow[];
        /**
         * An array with added workspaces
         */
        workspaces?: nodes.Workspace[];
    }

    /**
     * Represents an event for adding nodes to a group.
     */
    interface AddToGroupEvent extends BaseEvent {
        t: "addToGroup";
        /**
         * The group in which remove nodes
         */
        group: nodes.Group;
        /**
         * An array of nodes or one node to remove from the group
         */
        nodes?: nodes.BaseNode[] | nodes.BaseNode;
        /**
         * Either to re-add to parent group
         */
        reparent?: boolean;
    }

    /**
     * Represents an event for creating a group.
     */
    interface CreateGroupEvent extends BaseEvent {
        t: "createGroup";
        /**
         * An array with groups to remove
         */
        groups?: nodes.Group[];
    }

    /**
     * Represents an event for creating a subflow.
     */
    interface CreateSubflowEvent extends BaseEvent {
        t: "createSubflow";
        /**
         * The ID of the active workspace
         */
        activeWorkspace: nodes.UID;
        /**
         * An array with added links (during conversion to Subflow - links inside the subflow)
         */
        links?: nodes.Link[];
        /**
         * An array with subflow node IDs
         */
        nodes?: nodes.UID[];
        /**
         * An array with removed links (during conversion to Subflow - links from active workspace)
         */
        removedLinks?: nodes.Link[];
        /**
         * The subflow created to delete
         */
        subflow: {
            subflow: nodes.Subflow;
            offsetX?: number;
            offsetY?: number;
        };
    }
    
    /**
     * Represents an event for deleting elements from the history.
     */
    interface DeleteEvent extends BaseEvent {
        t: "delete";
        /**
         * An object with changes.
         * The key is the node ID and the value is an object with the changes
         */
        changes?: Record<nodes.UID, object>;
        /**
         * An array with created links
         */
        createdLinks?: nodes.Link[];
        /**
         * An array with removed groups
         */
        groups?: nodes.Group[];
        /**
         * An array with removed junctions
         */
        junctions?: nodes.Junction[];
        /**
         * An array with removed links
         */
        links?: nodes.Link[];
        /**
         * An array with removed nodes
         */
        nodes?: nodes.BaseNode[];
        subflow?: {
            id?: nodes.UID;
            instances?: nodes.BaseNode[];
            status?: string;
        };
        /**
         * An array with removed subflow input
         */
        subflowInputs?: nodes.SubflowNode[];
        /**
         * An array with removed subflow outputs
         */
        subflowOutputs?: nodes.SubflowNode[];
        /**
         * An array with removed subflows (tabs)
         */
        subflows?: nodes.Subflow[];
        /**
         * An array with removed workspace
         */
        workspaces?: nodes.Workspace[];
    }

    /**
     * Represents an event for deleting a subflow.
     */
    interface DeleteSubflowEvent extends BaseEvent {
        t: "deleteSubflow";
        /**
         * The id of the active workspace
         */
        activeWorkspace: nodes.UID;
        /**
         * An array with added links (during undo conversion to Subflow - links from active workspace)
         */
        createdLinks?: nodes.Link[];
        /**
         * An array with removed links (during undo conversion to Subflow - links inside the subflow)
         */
        links?: nodes.Link[];
        /**
         * An array with nodes to move to the subflow to create
         */
        movedNodes?: nodes.BaseNode[];
        /**
         * The deleted subflow to create
         */
        subflow: {
            subflow: nodes.Subflow;
            offsetX?: number;
            offsetY?: number;
        };
        /**
         * An array with subflow nodes (redo conversion to subflow)
         */
        subflows?: nodes.Subflow[];
    }

    /**
     * Represents an event for editing a node.
     */
    interface EditEvent extends BaseEvent {
        t: "edit";
        /**
         * The changed node state before modifications
         */
        changed: boolean;
        /**
         * An object with previous node properties value
         */
        changes: object;
        /**
         * An array with links to create (redo)
         */
        createdLinks?: nodes.Link[];
        /**
         * An array with removed links
         */
        links?: nodes.Link[];
        /**
         * The current node/subflow
         */
        node: nodes.BaseNode | nodes.Subflow;
        outputMap?: object;
        /**
         * Subflow properties
         */
        subflow?: {
            instances?: nodes.BaseNode[];
            inputCount?: number;
            outputCount?: number;
            status?: string;
        };
    }
    
    /**
     * Represents an event for moving nodes.
     */
    interface MoveEvent extends BaseEvent {
        t: "move";
        /**
         * The group in which the nodes were added
         */
        addToGroup?: nodes.Group;
        links?: nodes.Link[];
        /**
         * An array with nodes moved
         */
        nodes: { n: nodes.BaseNode; ox: number; oy: number; dx: number; dy: number }[];
        removedLinks?: nodes.Link[];
        /**
         * The group in which the nodes were removed
         */
        removeFromGroup?: nodes.Group;
    }
    
    /**
     * Represents an event for multiple sub-events.
     */
    interface MultiEvent extends BaseEvent {
        t: "multi";
        /**
         * An array with sub-events
         */
        events: HistoryEvent[];
    }

    /**
     * Represents an event for removing nodes from a group.
     */
    interface RemoveFromGroupEvent extends BaseEvent {
        t: "removeFromGroup";
        /**
         * The group in which add nodes
         */
        group: nodes.Group;
        /**
         * An array of nodes or one node to add to the group
         */
        nodes?: nodes.BaseNode[] | nodes.BaseNode;
        /**
         * Either to re-add to parent group
         */
        reparent?: boolean;
    }
    
    /**
     * Represents an event for reordering nodes or workspaces.
     */
    interface ReorderEvent extends BaseEvent {
        t: "reorder";
        nodes?: { from: string; to: string; z: string };
        workspaces?: {
            from: nodes.UID[];
            to: nodes.UID[];
        };
    }

    /**
     * Represents a replacement event (complete or incomplete).
     */
    type ReplaceEvent = CompleteReplaceEvent | IncompleteReplaceEvent;

    /**
    * Represents a complete replacement event.
    */
    interface CompleteReplaceEvent extends BaseEvent {
        t: "replace";
        /**
         * An object with a node id as key and the node changed property as value
         */
        changed: Record<string, boolean>;
        /**
         * Either the {@link ReplaceEvent.config} property contains the complete flows
         */
        complete: true;
        /**
         * An array with the complete flows
         */
        config: nodes.BaseNode[];
        /**
         * An object with a node ID as key and the node moved property as value
         */
        moved: Record<nodes.UID, boolean>;
        /**
         * A revision version
         */
        rev: string;
    }
    
    /**
    * Represents an incomplete replacement event.
    */
    interface IncompleteReplaceEvent extends BaseEvent {
        t: "replace";
        /**
         * Either the {@link ReplaceEvent.config} property contains the complete flows
         */
        complete?: false;
        /**
         * An array with config nodes and/or subflow definitions to replace.
         */
        config: nodes.BaseNode[];
    }

    /**
     * Represents an event for ungrouping nodes.
     */
    interface UngroupEvent extends BaseEvent {
        t: "ungroup";
        /**
         * An array with groups to create
         */
        groups?: nodes.Group[];
    }
}

export declare namespace i18n {
    type I18nT = (id: string, tplStrs?: Record<string, string | number>) => string;
}

export declare namespace notifications {
    type NotificationType = "warning" | "compact" | "success" | "error";
    interface NotificationOptions {
        fixed?: boolean;
        modal?: boolean;
        timeout?: number;
        type?: NotificationType;
        width?: number;
        buttons?:
            {
                class?: string | undefined;
                text: string;
                click: (event: JQuery.Event) => void;
            }[];
    }
    interface NotificationElement extends HTMLDivElement {
        readonly options?: NotificationOptions;
        close(): void;
        /** @internal */
        hideNotification(): void;
        /** @internal */
        showNotification(): void;
        update(msg: string | JQuery, options?: object): void;
        update(msg: string | JQuery, timeout?: number): void;
    }
}

export declare namespace plugins {
    /**
     * @link https://nodered.org/docs/api/ui/themes
     */
    interface PluginDefinition {
        module: string;
        /**
         * Called by {@link Plugins.registerPlugin}.
         */
        onadd?: () => void;
        type?: string;
    }
    interface PluginModule {
        id: string;
        local: boolean;
        name: string;
        pending_version?: string;
        plugin: true;
        sets: Record<string, PluginSet>;
        version: string;
    }
    interface PluginSet {
        editor: boolean;
        enabled: boolean;
        id: string;
        local: boolean;
        module: string;
        name: string;
        plugins: { id: string, module: string, type?: string }[];
        runtime: boolean;
        version: string;
    }
}

export interface ActionList {
    /** @internal */
    init(): void;
    /**
     * Hides the action list dialog.
     */
    hide(): void;
    /**
     * Shows the action list dialog.
     * @param filter The filter to apply to the list
     */
    show(filter?: string): void;
}

export interface Actions {
    add(name: string, handler: (...args: any[]) => void, options?: object): void;
    get(name: string): (...args: any[]) => void;
    /**
     * Used to get or generate and translate action label
     */
    getActionLabel(name: string): string;
    invoke(name: string, ...args: any[]): void;
    list(): { id: string; scope?: string; key?: string; user: boolean; label?: string; options?: object }[];
    remove(name: string): void;
}

export interface Comms {
    /** @internal */
    connect(): void;
    /** @internal */
    on(event: string, listener: (...args: any[]) => void): void;
    /** @internal */
    off(event: string, listener: (...args: any[]) => void): void;
    /**
     * Sends data to the runtime
     */
    send(topic: string, data: any): void;
    subscribe(topic: string, callback: (topic: string, data: any) => void): void;
    unsubscribe(topic: string, callback: (topic: string, data: any) => void): void;
}

export interface Events<L extends events.ListenerSignature<L> = events.Events> {
    /**
     * Registers a new handler for the given event.
     * @param event The name of the event to listen
     * @param listener The handler function to add
     * @example
     * RED.events.on("nodes:add", function (node) {
     *   console.log("A node has been added to the workspace!")
     * });
     * @link https://nodered.org/docs/api/ui/events/#methods-on
     */
    on<U extends keyof L>(event: U, listener: L[U]): void;
    /**
     * Removes a previously registered event handler.
     * @param event The name of the event
     * @param listener The handler function to remove
     * @link https://nodered.org/docs/api/ui/events/#methods-off
     */
    off<U extends keyof L>(event: U, listener: L[U]): void;
    /**
     * Emits a event with the supplied arguments
     * @param event The name of the event
     * @param args The argument list
     */
    emit<U extends keyof L>(event: U, ...args: Parameters<L[U]>): void;
}

export interface History {
    /**
     * @internal
     */
    markAllDirty(): void;
    /**
     * Returns a list with undo events.
     */
    list(): history.HistoryEvent[];
    /**
     * Returns a list with redo events.
     */
    listRedo(): history.HistoryEvent[];
    /**
     * Returns the size of the list with redo events.
     */
    depth(): number;
    /**
     * Pushes an event to the History. This event can be undo by
     * calling {@link History.pop pop}().
     * @param event The event to push
     */
    push(event: history.HistoryEvent): void;
    /**
     * Called to undo an event.
     * Takes the last event of the undo list, do undo event and adds
     * the redo event generated to the redo list.
     */
    pop(): void;
    /**
     * Returns the last event of undo list.
     */
    peek(): history.HistoryEvent;
    /**
     * Replaces the last event of undo list by the event given
     * in parameter.
     * @param event The event to replace
     */
    replace(event: history.HistoryEvent): void;
    /**
     * Clears the undo list and redo list.
     */
    clear(): void;
    /**
     * Called to redo an event.
     * Takes the last event of the redo list, do redo event and adds
     * the undo event generated to the undo list.
     */
    redo(): void;
}

export interface MultiPlayer {
    /** @internal */
    init(): void;
}

export interface Nodes {
    //readonly registry: nodes.Registry;

    /**
     * Cleans all nodes and workspaces. Returns to a clean state before the first import.
     */
    clear(): void;
    /**
     * Get the dirty state of the editor. `Dirty` means there are undeployed changes.
     */
    dirty(): boolean;
    /**
     * Defines the dirty state of the editor. Triggers the {@link events.Events workspace:dirty} event.
     * @param dirty 
     */
    dirty(dirty: boolean): void;
    /**
     * Generates a unique node ID.
     */
    id(): nodes.UID;
    version(): string;
    version(version: string): void;

    node(id: nodes.UID): nodes.BaseNode | null;
    add(node: nodes.NodeObject): nodes.BaseNode;
    
    remove(id: nodes.UID): { links: nodes.Link[]; nodes: nodes.BaseNode[] };

    group(id: nodes.UID): nodes.Group | null;

    junction(id: nodes.UID): nodes.Junction | null;

    getNodeLinks(id: nodes.UID, portType: 0 | 1): nodes.Link[];
    /** @deprecated */
    getNodeLinks(link: nodes.Link, portType: 0 | 1): nodes.Link[];

    subflow(id: nodes.UID): nodes.Subflow | null;
    /**
     * Add a Subflow to the Workspace
     * @param subflow The Subflow to add
     * @param updateName Whether to update the name.
     */
    addSubflow(subflow: nodes.NodeObject<nodes.Subflow>, updateName?: boolean): void;
    removeSubflow(subflow: nodes.Subflow): void;
    subflowContains(subflowId: nodes.UID, nodeId: nodes.UID): boolean;

    workspace(id: nodes.UID): nodes.Workspace | null;
    addWorkspace(workspace: nodes.NodeObject<nodes.Workspace>, targetIndex?: number): void;
    removeWorkspace(id: nodes.UID): {
        nodes: nodes.BaseNode[];
        links: nodes.Link[];
        groups: nodes.Group[];
        junctions: nodes.Junction[]
    };
    getWorkspaceOrder(): nodes.UID[];
    setWorkspaceOrder(order: nodes.UID[]): void;

    eachConfig(callback: (node: nodes.ConfigNode) => void | false): void;
    eachGroup(callback: (node: nodes.Group) => void | false): void;
    eachJunction(callback: (node: nodes.Junction) => void | false): void;
    eachLink(callback: (node: nodes.Link) => void | false): void;
    eachNode(callback: (node: nodes.BaseNode) => void | false): void;
    eachSubflow(callback: (node: nodes.Subflow) => void | false): void;
    eachWorkspace(callback: (node: nodes.Workspace) => void | false): void;

    import(nodes, options): {
        nodes: nodes.BaseNode[];
        links: {
            source: nodes.BaseNode;
            sourcePort: number;
            target: nodes.BaseNode;
        }[];
        groups: nodes.Group[];
        junctions: nodes.Junction[];
        workspaces: nodes.Workspace[];
        subflows: nodes.Subflow[];
        missingWorkspace: nodes.Workspace;
        removedNodes: nodes.BaseNode[] | undefined;
    } | undefined;

    originalFlow(): nodes.NodeObject[];
    /** @internal */
    originalFlow(flow: nodes.NodeObject[]): void;

    /**
     * Converts a node to an exportable JSON Object
     */
    convertNode(node: nodes.BaseNode, exportCreds: boolean): nodes.NodeObject;
    /**
     * Converts the current node selection to an exportable JSON Object
     */
    createExportableNodeSet(
        set: object[],
        exportedIds?: object,
        exportedSubflows?: object,
        exportedConfigNodes?: object,
    ): Array<nodes.NodeObject>;
    /**
     * Converts the complete flow to an exportable JSON Object
     */
    createCompleteNodeSet(options?: { credentials?: boolean, dimensions?: boolean }): Array<nodes.NodeObject>;
    updateConfigNodeUsers(node: nodes.Node, options?: { action?: "add" | "remove", emitEvent?: boolean }): void;
}

export interface Notifications {
    /**
     * If set to true, all notifications will be hidden.
     * @internal
     */
    hide?: boolean;
    /** @internal */
    init(): void;
    /**
     * @example
     * // Plain information notification
     * RED.notify("Hello World");
     * // Warning notification for 10 seconds
     * RED.notify("Something has happened", { type: "warning", timeout: 10000 });
     * // Notification with buttons
     * let myNotification = RED.notify("This is the message to display", {
     *   modal: true,
     *   fixed: true,
     *   type: "warning",
     *   buttons: [
     *     {
     *        text: "cancel",
     *        click: function (e) {
     *          myNotification.close();
     *        }
     *     },
     *     {
     *        text: "okay",
     *        class: "primary",
     *        click: function (e) {
     *          myNotification.close();
     *        }
     *     }
     *   ]
     * });
     */
    notify(msg: string | JQuery, options?: notifications.NotificationOptions): notifications.NotificationElement;
    notify(msg: string | JQuery, type?: notifications.NotificationType): notifications.NotificationElement;
    /** @deprecated please use options instead */
    notify(msg: string | JQuery, type?: notifications.NotificationType, fixed?: boolean, timeout?: number): notifications.NotificationElement;
}

export interface Plugins {
    /**
     * Adds the plugin module to the module lists.
     * @internal
     */
    addPlugin(plugin: plugins.PluginModule): void;
    /**
     * Gets the plugin module from the module lists.
     * @internal
     */
    getModule(module: string): plugins.PluginModule | null;
    /**
     * Gets the plugin definition from the registry.
     */
    getPlugin(id: string): plugins.PluginDefinition | null;
    /**
     * Gets a list of plugin definitions for the given type.
     */
    getPluginsByType(id: string): plugins.PluginDefinition[];
    /**
     * Adds the plugin definition to the registry.
     */
    registerPlugin(id: string, definition: plugins.PluginDefinition): void;
    /**
     * Calls {@link addPlugin} for each element of the list.
     * @internal
     */
    setPluginList(list: plugins.PluginModule[]): void;
}

export interface Runtime {
    /** @internal */
    init(): void;
    readonly started: "start" | "stop" | "safe" | "";
}

export interface Settings {
    /**
     * Gets the setting from the user or NR exposed settings.
     * @param key The key to the setting to search for
     * @param defaultValue The default value if undefined
     * @example
     * // Returns an object
     * RED.settings.get("editor")
     * // Return a string
     * RED.settings.get("debug.filter")
     * // Returns undefined
     * RED.settings.get("fake")
     */
    get<T = any>(key: string, defaultValue: T): T;
    get<T = any>(key: string): T | undefined;
    /**
     * Gets an item from the {@link Storage localStorage}.
     */
    getLocal(key: string): string | null;
    /** @internal */
    init(options: { apiRootUrl: string; }, done: () => void): void;
    /** @internal */
    load(done: () => void): void;
    /** @internal */
    loadUserSettings(done: () => void): void;
    refreshSettings(done: () => void): void;
    /**
     * Sets and saves the user setting
     */
    set(key: string, value: any): void;
    /**
     * Sets an item to {@link Storage localStorage}.
     */
    setLocal(key: string, value: any): void;
    /**
     * Removes and saves the user setting
     */
    remove(key: string): void;
    /**
     * Removes an item from the {@link Storage localStorage}.
     */
    removeLocal(key: string): void;
    /**
     * Gets (like {@link get}) the property from the theme settings.
     */
    theme<T = any>(property: string, defaultValue: T): T;
    theme<T = any>(property: string): T | undefined;
}

export interface User {
    generateUserIcon(user: object): JQuery<HTMLElement>;
    hasPermission(permission: string | string[]): boolean;
    /** @internal */
    init(): void;
    login(done: () => void): void;
    login(options: { cancelable?: boolean; updateMenu?: boolean }, done: () => void): void;
    logout(): void;
}

export interface Validators {
    number(allowBlanck?: boolean): nodes.PropertyValidator;
    regex(regex: RegExp): nodes.PropertyValidator;
    /** @deprecated */
    typedInput(typeField: string, isConfigNode?: boolean): nodes.PropertyValidator;
    typedInput(options: { allowBlank?: boolean, isconfig?: boolean, typeField: string }): nodes.PropertyValidator;
}

export interface RED {
    _: i18n.I18nT;
    actionList: ActionList;
    /**
     * This API can be used to register and invoke Actions in the editor.
     * Actions are individual pieces of functionality that a user may want
     * to trigger and can be bound to keyboard shortcuts.
     * @link https://nodered.org/docs/api/ui/actions
     */
    actions: Actions;
    /**
     * This Comms API provides a real-time connection between the runtime and the editor via a WebSocket.
     * The network overhead of this connection **MUST** be kept as low as possible.
     */
    comms: Comms;
    /**
     * The editor emits events that components can listen for so they can react as needed.
     * @link https://nodered.org/docs/api/ui/events
     */
    events: Events;
    /**
     * The History API for undo / redo history buffer
     */
    history: History;
    multiplayer: MultiPlayer;
    /**
     * The Nodes API
     */
    nodes: Nodes;
    notify: Notifications["notify"];
    /**
     * This API can be used to display notifications that pop-down from the top of the editor.
     * @link https://nodered.org/docs/api/ui/notifications
     */
    notifications: Notifications;
    plugins: Plugins;
    runtime: Runtime;
    settings: Settings;
    /**
     * @link https://nodered.org/docs/creating-nodes/properties#property-validation
     */
    validators: Validators;
}

declare global {
    /**
     * The Node-RED Editor API
     */
    var RED: RED;

    // TODO: JQuery + typedInput + editableList
}
