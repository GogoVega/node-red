const { compare, satisfies } = require("semver");
const { getModuleList } = require("@node-red/registry");
const { util: { getObjectProperty } } = require("@node-red/util");

/** @type {import("got").Got} */
let got;

/** @type {string[]} */
let catalogues = [];
/** @type {object[]} */
let loadedCatalogs = [];
/** @type {number} */
let loadedAt;

let installAllowed = true;
let installAllowList = ['*'];
let installDenyList = [];
let updateAllowed = true;
let updateAllowList = ['*'];
let updateDenyList = [];

let runtime;

const CACHE_LIFETIME = 30 * 60 * 1000; // 30min

// TODO: check version
function checkAgainstList(module, version, list) {
    for (var i = 0; i < list.length; i++) {
        var rule = list[i];
        if (rule.module.test(module)) {
            // Without a full semver library in the editor,
            // we skip the version check.
            // Not ideal - but will get caught in the runtime
            // if the user tries to install.
            return rule;
        }
    }
}

function checkModuleAllowed(module, version, allowList, denyList) {
    if (!allowList && !denyList) {
        // Default to allow
        return true;
    }
    if (allowList.length === 0 && denyList.length === 0) {
        return true;
    }

    const allowedRule = checkAgainstList(module, version, allowList);
    const deniedRule = checkAgainstList(module, version, denyList);

    if (allowedRule && !deniedRule) {
        return true;
    }
    if (!allowedRule && deniedRule) {
        return false;
    }
    if (!allowedRule && !deniedRule) {
        return true;
    }
    if (allowedRule.wildcardPos !== deniedRule.wildcardPos) {
        return allowedRule.wildcardPos > deniedRule.wildcardPos
    } else {
        // First wildcard in same position.
        // Go with the longer matching rule. This isn't going to be 100%
        // right, but we are deep into edge cases at this point.
        return allowedRule.module.toString().length > deniedRule.module.toString().length
    }
}

function checkEngines(entry) {
    if (entry.engines && typeof entry.engines === "object") {
        const engines = entry.engines;

        // To avoid unsupported engines
        entry.engines = {};

        if (engines.node) {
            entry.engines.node = {
                current: process.version,
                required: engines.node,
                satisfied: satisfies(process.version, engines.node),
            };
        }

        if (engines["node-red"]) {
            entry.engines["node-red"] = {
                current: runtime.settings.version,
                required: engines["node-red"],
                satisfied: satisfies(runtime.settings.version, engines["node-red"], { includePrerelease: true }),
            };
        }
    } else if (entry.engines) {
        const error = new Error();
        error.code = "unsupported_engines_format";
        throw error;
    }
}

function checkUpdate(entry, moduleList) {
    delete entry.updateAvailable;

    const module = moduleList[entry.id];
    if (!module || !updateAllowed) {
        // Module not installed or update not allowed
        return false;
    }

    if (entry.engines && Object.values(entry.engines).some((e) => e.satisfied === false)) {
        // One or more engines are not satisfied - ignore the update
        return false;
    }

    if (checkModuleAllowed(entry.id, entry.version, updateAllowList, updateDenyList)) {
        // Update is allowed for this module
        if (compare(entry.version, module.pending_version || module.version) > 0) {
            // An update is available
            entry.updateAvailable = true;
        }
    }
}

function checkInstallAllowed(module) {
    return (
        installAllowed &&
        checkModuleAllowed(module.id, module.version, installAllowList, installDenyList)
    );
}

function parseModuleList(list) {
    list = list || ["*"];
    return list.map(function (rule) {
        const m = /^(.+?)(?:@(.*))?$/.exec(rule);
        let wildcardPos = m[1].indexOf("*");
        wildcardPos = wildcardPos === -1 ? Infinity : wildcardPos;

        return {
            module: new RegExp("^" + m[1].replace(/\*/g, ".*") + "$"),
            version: m[2],
            wildcardPos: wildcardPos
        }
    })
}

function getCatalogues() {
    return Promise.all(
        catalogues.map(async (url, index) => {
            const { name, updated_at, modules = [] } = await got.get(url + "?_=" + Date.now()).json();
            return {
                index,
                url,
                name,
                updated_at,
                modules_count: modules.length,
                modules,
            };
        })
    );
}

async function refreshCatalogues(reload) {
    if (!got) {
        got = (await import('got')).got;
    }

    const isCached = loadedCatalogs.length > 0 && !reload && (Date.now() - loadedAt) < CACHE_LIFETIME;
    if (isCached) {
        updateCatalogueModules();
        return loadedCatalogs;
    }

    loadedCatalogs = await getCatalogues();
    loadedAt = Date.now();

    const moduleList = getModuleList();
    for (const catalogue of loadedCatalogs) {
        catalogue.modules = catalogue.modules.filter(function (m) {
            if (checkInstallAllowed(m)) {
                m.catalog = { url: catalogue.url, name: catalogue.name };
                m.catalogIndex = catalogue.index;
                m.index = [m.id];
                if (m.keywords) {
                    m.index = m.index.concat(m.keywords);
                }
                if (m.types) {
                    m.index = m.index.concat(m.types);
                }

                if (m.updated_at) {
                    m.timestamp = new Date(m.updated_at).getTime();
                } else {
                    m.timestamp = 0;
                }

                m.index = m.index.join(",").toLowerCase();

                checkEngines(m);
                checkUpdate(m, moduleList);

                return true;
            }

            return false;
        });
    }

    return loadedCatalogs;
}

function updateCatalogueModules() {
    const moduleList = getModuleList();
    for (const catalogue of loadedCatalogs) {
        catalogue.modules.forEach(function (m) {
            checkUpdate(m, moduleList);
        });
    }
}

function getSetting(expression, defaultValue) {
    let value;
    try {
        value = getObjectProperty(runtime.settings, expression);
    } catch (_error) { }
    if (value === undefined) {
        value = defaultValue;
    }
    return value;
}

function getSettings() {
    const settingsAllowList = getSetting("externalModules.palette.allowList");
    const settingsDenyList = getSetting("externalModules.palette.denyList")
    const settingsUpdateAllowList = getSetting("externalModules.palette.allowUpdateList")
    const settingsUpdateDenyList = getSetting("externalModules.palette.denyUpdateList")

    if (settingsAllowList || settingsDenyList) {
        installAllowList = settingsAllowList;
        installDenyList = settingsDenyList;
    }
    if (settingsUpdateAllowList || settingsUpdateDenyList) {
        updateAllowList = settingsUpdateAllowList;
        updateDenyList = settingsUpdateDenyList;
    }

    installAllowed = getSetting("externalModules.palette.allowInstall", true);
    installAllowList = parseModuleList(installAllowList);
    installDenyList = parseModuleList(installDenyList);

    updateAllowed = getSetting("externalModules.palette.allowUpdate", true);
    updateAllowList = parseModuleList(updateAllowList);
    updateDenyList = parseModuleList(updateDenyList);

    catalogues = getSetting("editorTheme.palette.catalogues", ["https://catalogue.nodered.org/catalogue.json"]);
}

module.exports = {
    init: function (_runtime) {
        runtime = _runtime;
    },
    getCatalogues: async function (opts) {
        return new Promise(function (resolve, reject) {
            runtime.log.audit({ event: "palette.getCatalogues", reload: opts.reload }, opts.req);

            if (!catalogues.length) {
                getSettings();
            }

            refreshCatalogues(opts.reload)
                .then((catalogues) => resolve(catalogues))
                .catch((error) => {
                    if (!error.status) {
                        error.status = 500;
                    }
                    reject(error);
                });
        });
    },
};
