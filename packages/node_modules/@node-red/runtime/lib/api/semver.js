const { compare, satisfies } = require("semver");

let runtime;

/**
 * @typedef {{ current: string, required: string, satisfied: boolean }} Engine
 * @typedef {{ engines?: { node?: Engine, "node-red"?: Engine } }} Engines
 * @typedef {{ engines?: { node?: string, "node-red"?: string } }} Entry
 * @param {Entry|Entry[]} entryList
 * @param {(engines: Engines|Engines[]) => void} callback
 */
function checkEngines(entryList, callback) {
    let returnObject = false;

    if (!Array.isArray(entryList)) {
        entryList = [entryList];
        returnObject = true;
    }

    for (const entry of entryList) {
        if (entry.engines && typeof entry.engines === "object") {
            const engines = entry.engines;

            // To avoid unsupported engines
            entry.engines = {};

            if (engines.node) {
                entry.engines.node = {
                    current: process.version,
                    required: engines.node,
                    satisfied: satisfies(process.version, engines.node),
                };
            }

            if (engines["node-red"]) {
                entry.engines["node-red"] = {
                    current: runtime.settings.version,
                    required: engines["node-red"],
                    satisfied: satisfies(runtime.settings.version, engines["node-red"], { includePrerelease: true }),
                };
            }
        } else if (entry.engines) {
            const error = new Error();
            error.code = "unsupported_engine_format";
            error.satus = 400;
            throw error;
        }
    }

    callback(returnObject ? entryList[0].engines || {} : entryList);
}

module.exports = {
    init: function (_runtime) {
        runtime = _runtime;
    },
    /**
    * Checks an engine definition
    * @param {object} opts
    * @param {User} opts.user - the user calling the api
    * @param {Entry|Entry[]} opts.engines - the engine to check
    * @param {object} opts.req - the request to log (optional)
    * @return {Promise<Engines|Engines[]>} - an new engine object
    * @memberof @node-red/runtime_semver
    */
    checkEngines: async function (opts) {
        return new Promise(function (resolve, reject) {
            try {
                // TODO: audit engines body?
                runtime.log.audit({ event: "semver.checkEngines" }, opts.req);
                checkEngines(opts.engines, (result) => resolve(result));
            } catch (error) {
                if (!error.status) {
                    error.status = 500;
                }
                reject(error);
            }
        });
    },
    /**
    * Compares two versions
    * @param {object} opts
    * @param {User} opts.user - the user calling the api
    * @param {string} opts.v1 - the first version
    * @param {string} opts.v2 - the second version
    * @param {object} opts.req - the request to log (optional)
    * @return {Promise<-1|0|1>} - the result of comparaison
    * @memberof @node-red/runtime_semver
    */
    compare: async function (opts) {
        return new Promise(function (resolve, reject) {
            try {
                runtime.log.audit({ event: "semver.compare", v1: opts.v1, v2: opts.v2 }, opts.req);
                // TODO: allow includePrerelease?
                resolve(compare(opts.v1, opts.v2));
            } catch (error) {
                error.status = 500;
                reject(error);
            }
        });
    },
    /**
    * Return true if the version satisfies the range
    * @param {object} opts
    * @param {User} opts.user - the user calling the api
    * @param {string} opts.version - the version
    * @param {string} opts.range - the range to compare
    * @param {object} opts.req - the request to log (optional)
    * @return {Promise<boolean>} - `true` if the version satisfies the range
    * @memberof @node-red/runtime_semver
    */
    satisfies: async function (opts) {
        return new Promise(function (resolve, reject) {
            try {
                runtime.log.audit({ event: "semver.satisfies", version: opts.version, range: opts.range }, opts.req);
                // TODO: allow includePrerelease?
                resolve(satisfies(opts.version, opts.range));
            } catch (error) {
                error.status = 500;
                reject(error);
            }
        });
    },
};
